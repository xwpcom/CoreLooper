////////////////////////////////////////////////////////////////////////////////////////////
2021.01.13//////////////////////////////////////////////////////////////////////////////////
bug fixed:
昨天改动后出现大量的tagItemInfo& info为空的情况导致crash
LRESULT DnsLooper::OnMessage(UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case BM_ADD_REQUEST:
	{
		tagItemInfo& info = *(tagItemInfo*)wp;
//已解决,是Looper_Windows::getMessage昨天改动意外返回0引起的


////////////////////////////////////////////////////////////////////////////////////////////
2021.01.12//////////////////////////////////////////////////////////////////////////////////
changes:
.iocp改用GetQueuedCompletionStatusEx,可批量取回结果

todo:
.ByteBuffer改进的想法
ByteBuffer内置shared_ptr<Buffer>,外界通过ByteBuffer间接访问Buffer
每个looper都集成批量分配ByteBuffer和Buffer并缓存到pool中
ByteBuffer返回给user,ByteBuffer析构时把Buffer归还给looper
相当于借助ByteBuffer的RAII实现Buffer的循环使用

////////////////////////////////////////////////////////////////////////////////////////////
2021.01.11//////////////////////////////////////////////////////////////////////////////////
最近发现iot经常crash在libhttp.dll
可能是call stack耗尽，导致没法生成.dmp文件
也可能是陷入死循环,导致watchdog干掉iot并重启
TEST_METHOD(StressTest)

////////////////////////////////////////////////////////////////////////////////////////////
2021.01.06//////////////////////////////////////////////////////////////////////////////////
changes:
.timer优化:
TimerManager::GetMinIdleTime不需要每次loop都判断
引入looper tick和io idle tick
当io繁忙时直接返回1ms,可避免绝大部分冗余的MinIdleTime计算

todo:
.Channel重构
 直接LPBYTE data,int bytes给调用者，不要先采用ByteBuffer缓存，再提供给caller

////////////////////////////////////////////////////////////////////////////////////////////
2020.12.17//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.TcpClient_Windows::OnRecv中
如果先PostRecv再调用OnReceive()解析数据，可能出现重入问题,细节如下
出现过在OnReceive()中处理inbox时,采用sendMessage解析dns,结果在等待回复时又收到OnReceive()事件,如此循环，直到stack耗尽导致crash
解决办法:在OnReceive()之后才触发新的PostRecv

.SerialPort_Windows::OnRecv也做了修改

////////////////////////////////////////////////////////////////////////////////////////////
2020.10.05//////////////////////////////////////////////////////////////////////////////////
.ctp中去掉了OnCommandAck,全部采用notify即可


////////////////////////////////////////////////////////////////////////////////////////////
2020.08.21//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.fix StringParam::ParseItems中异常截断
	auto config = "url=http://36.152.66.126:9023/scsv2server/electricity/realdata?apikey=D63EC437-A04A-206D-6392-3E7569A8FA58";
	auto ack = StringParam::ParseItems(config);
当k1=v1中v1里面有=时，解析异常截断

////////////////////////////////////////////////////////////////////////////////////////////
2020.07.15//////////////////////////////////////////////////////////////////////////////////
目前json用的是arduinojson 5.x,它不支持unicode unescape
arduinojson 6.x才支持，但发现它不兼容5.x,所以没法平滑升级
现有工程大量已采用5.x用法

////////////////////////////////////////////////////////////////////////////////////////////
2020.07.14//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.StringTool::Replace

////////////////////////////////////////////////////////////////////////////////////////////
2020.07.08//////////////////////////////////////////////////////////////////////////////////
todo:
.增加共享内存版LogV(低优先级),提高log性能
 目前的实现方法对我们的应用场景来说是够用的
.不考虑采用写文件的方式来做log,
 任何需要app自行初始化才能使用的log机制都不予考虑
 像printf,OutputDebugString这样能直接使用的方式才比较方便

////////////////////////////////////////////////////////////////////////////////////////////
2020.07.07//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.SimpleConnect在调用OnDestroy()之后再调用SimpleConnect::StartConnect强引用mChannel,会导致无法正常析构
//解决办法:在destroy之后不再强引用

////////////////////////////////////////////////////////////////////////////////////////////
2020.07.06//////////////////////////////////////////////////////////////////////////////////
todo:
.SetTimer增加lambda fn,这样有时更方便一些

////////////////////////////////////////////////////////////////////////////////////////////
2020.06.16//////////////////////////////////////////////////////////////////////////////////
changes:
.增加了TcpListener和TcpServer2_Windows,多端口可以使用了,后续再集成到TcpServer_Windows

////////////////////////////////////////////////////////////////////////////////////////////
2020.06.15//////////////////////////////////////////////////////////////////////////////////
.tcp listener应该独立出来
 有时同一业务为方便对单个设备连接进行抓包追踪，可叫此设备连接到特定的端口
 目前一个TcpServer只能侦听一个port,很不方便
 或者增加一个AddBindPort接口
.取名TcpListener,发现.net框架中也是这个名字

////////////////////////////////////////////////////////////////////////////////////////////
2020.06.08//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.TcpClient_Windows::Send中mTlsInfo->mSslBox->onSend()不能复用outBuffer,每次都要创建新的<BufferRaw>();
 SslBox内部没有复制，而是直接缓存此shared_ptr<BufferRaw>

////////////////////////////////////////////////////////////////////////////////////////////
2020.05.27//////////////////////////////////////////////////////////////////////////////////
todo:
.OnProcDataGetter应该改为unordered_map<string,string>,用来支持添加多个字段

////////////////////////////////////////////////////////////////////////////////////////////
2020.05.26//////////////////////////////////////////////////////////////////////////////////
https://github.com/google/sanitizers/wiki/AddressSanitizer
在linux下检查内存bug可在编译时加上-fsanitize=address -g  
测试
bear@bear-win10:~$ vi ./t.cpp
#include <stdio.h>

int main()
{
        int *p=new int;
        delete p;
        delete p;

        printf("hello\r\n");
        return 0;
}

bear@bear-win10:~$ g++ -fsanitize=address -g   t.cpp -o ./t
bear@bear-win10:~$ ./t
=================================================================
==4236==ERROR: AddressSanitizer: attempting double-free on 0x602000000010 in thread T0:
    #0 0x7f43a8701025 in operator delete(void*, unsigned long) (/lib/x86_64-linux-gnu/libasan.so.5+0x111025)
    #1 0x7f43a907924e in main /home/bear/t.cpp:7
    #2 0x7f43a84170b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)
    #3 0x7f43a907914d in _start (/home/bear/t+0x114d)

0x602000000010 is located 0 bytes inside of 4-byte region [0x602000000010,0x602000000014)
freed by thread T0 here:
    #0 0x7f43a8701025 in operator delete(void*, unsigned long) (/lib/x86_64-linux-gnu/libasan.so.5+0x111025)
    #1 0x7f43a9079238 in main /home/bear/t.cpp:6
    #2 0x7f43a84170b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

previously allocated by thread T0 here:
    #0 0x7f43a86ff947 in operator new(unsigned long) (/lib/x86_64-linux-gnu/libasan.so.5+0x10f947)
    #1 0x7f43a907921e in main /home/bear/t.cpp:5
    #2 0x7f43a84170b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

SUMMARY: AddressSanitizer: double-free (/lib/x86_64-linux-gnu/libasan.so.5+0x111025) in operator delete(void*, unsigned long)
==4236==ABORTING
bear@bear-win10:~$

////////////////////////////////////////////////////////////////////////////////////////////
2020.05.25//////////////////////////////////////////////////////////////////////////////////
.为支持iot低功耗,TcpClient_Windows::OnConnect中SIO_KEEPALIVE_VALS间隔时间加大

////////////////////////////////////////////////////////////////////////////////////////////
2020.03.31//////////////////////////////////////////////////////////////////////////////////
depends中的openssl和vcpkg openssl有冲突，解决办法:
vcpkg remove openssl-windows:x86-windows

////////////////////////////////////////////////////////////////////////////////////////////
2020.02.10//////////////////////////////////////////////////////////////////////////////////
todo:
.ByteBuffer应该增加引用stack buffer的功能
 在某些情况下可提高性能，避免频繁的new/delete

 .在TEST_CLASS(Log)中测试了critical section,mutex和WM_COPYDATA的性能
WM_COPYDATA tick=2250,nc=100000,注意只测试了10万次，比mutex慢了约20倍
Mutex,tick=1359,nc=1000000
CS tick=16,nc=1000000,可以看到critical section比mutex快很多,但不支持跨进程
 
////////////////////////////////////////////////////////////////////////////////////////////
2020.02.08//////////////////////////////////////////////////////////////////////////////////
changes:
.重构了DT和Log,支持LogV,LogD,LogI,LogW,LogE打印到新版DT
.DT支持app,tag,level过滤,与android studio logcat类似,支持多tab

////////////////////////////////////////////////////////////////////////////////////////////
2020.01.09//////////////////////////////////////////////////////////////////////////////////
【话唠】铁铁<zlw0905@qq.com> 01/09/2020 09:31:30
@熊子良 群主，写了个程序跑linux上，cpu100%用啥工具分析一下呀/呲牙
【群主】熊子良(771730766) 01/09/2020 09:33:47
gdb -p pid
【话唠】无相(35760982) 01/09/2020 09:34:26
先找到百分之百的线程
top -Hp 进程ip
id
【群主】熊子良(771730766) 01/09/2020 09:35:29
gdb -p pid 然后进去，暂停程序 然后看bt 哪条线程停顿在非阻塞代码 基本就能判断该线程就是100%的线程
【话唠】无相(35760982) 01/09/2020 09:35:48
嗯，这么判断也可以
实在没有阻塞了，时间片到了只能让出去，呵呵

////////////////////////////////////////////////////////////////////////////////////////////
2020.01.07//////////////////////////////////////////////////////////////////////////////////
todo:
proc.xml中子节点太多时，需要定位到特定的节点,需要扩展一下url的用法
目前是proc.xml?url=IotServer
当IotServer下有多个IotHandler时
url=IotServer/IotHandler.uid[00000]
约定object name中不含.[]字符
当某段url中包含这几个特殊字符串时,解析为
name.tag[keyword]
name是object name
tag和keyword传给FindObject()搜索匹配的handler

.
void TcpClient_Windows::ConfigCacheBox()
{
	{
		//todo:
		//2020.01.07
		//mSslBox->setOnEncData目前没做渐进处理，
		//libiot做的微信小程序查询历史记录可能比较大,outbox要足够大能容纳下
		//后续改进
		mOutbox.SetBufferSize(4 * 1024, 16*1024 * 1024);

////////////////////////////////////////////////////////////////////////////////////////////
2019.12.25//////////////////////////////////////////////////////////////////////////////////
bug:
.发现Channel OnReceive有重入现象,即在处理inbox数据的过程中又进入OnReceive,会导致解析异常
 通过ByteBuffer::AssertNotLocked()检查到此现象
//已在TcpClient_Windows::OnRecv采用bool避免重入问题
//其他类，比如串口等也可能有类似问题,有待想办法彻底解决
此问题本质是在处理GetMessage的过程中又调用了GetMessage,导致inbox接收数据嵌套

想法:
.升级ByteBuffer,每次OnRecv到新的ByteBuffer,而不是像现在这样recv用同一个ByteBuffer inbox接收
 可避免上面的bug
.ByteBuffer支持子ByteBuffer,接口支持聚合
.支持pool重用,ByteBuffer内部采用shared_ptr引用真正的buffer
 ByteBuffer析构时把buffer返还给pool

////////////////////////////////////////////////////////////////////////////////////////////
2019.12.17//////////////////////////////////////////////////////////////////////////////////
changes:
.采用SSL_CTX_load_verify_locations加载ssl中间证书

////////////////////////////////////////////////////////////////////////////////////////////
2019.12.05//////////////////////////////////////////////////////////////////////////////////
changes:
.https server重构
 和普通http server的区别是
 .要调用TcpServer_Windows::InitSSL设定证书
 .要调用EnableTls()
 .端口由80改为443或其他
	string folder = "D:/bear/server/bin/";
	auto crtFile = folder + "bear.jjyip.com.p12";
	TcpServer_Windows::InitSSL(crtFile);

	auto svr(make_shared<HttpServer>());
	svr->EnableTls();
	AddChild(svr);

	int ret = svr->StartServer(443);

.http/https client/server在windows下都能正常工作了
 调用EnableTls()即可，和普通用法一样了

已知问题:
openssl init有memory leak,不会积累

////////////////////////////////////////////////////////////////////////////////////////////
2019.11.26//////////////////////////////////////////////////////////////////////////////////
changes:
.https server初步ok,以后再做https client

////////////////////////////////////////////////////////////////////////////////////////////
2019.11.25//////////////////////////////////////////////////////////////////////////////////
changes:
.libhttp测试https ok
 参照了zlmediakit中的openssl用法

.https下载超大文件改进
https://xwpcom.tpddns.cn/x.rar
会报很多ByteByteffer overflow,但下载的文件是正常的
//没再重现

.给vs写一个插件，实现类似android studio logcat功能，结合MemoryLog
 在vs中像Text Explorer那样作为一个面板使用

////////////////////////////////////////////////////////////////////////////////////////////
2019.10.31//////////////////////////////////////////////////////////////////////////////////
spdlog日志做的不错，代码在
E:\os\spdlog\build

////////////////////////////////////////////////////////////////////////////////////////////
2019.10.29//////////////////////////////////////////////////////////////////////////////////
如果main()已结束，但process还没结束时,如果还有子线程在运行,此时的行为感觉是未定义的

////////////////////////////////////////////////////////////////////////////////////////////
2019.10.27//////////////////////////////////////////////////////////////////////////////////
todo:
.MemoryLog可用atexit作标记位
 在atexit api执行之后，每次重新创建再删除logger
 这样可避免false memory leak
.MemoryLog可检测log丢失,可自动转移/扩充buffer大小
 共享区分为header和body
 header中有process id
 body采用TLV
 type采用两个ascii字符表示，比如,TI表示thread id
 length采用2 bytes,即限定了单条log总长度为64KB,对log来说是足够的
.每个log的字段
thread id
tag
msg
level




////////////////////////////////////////////////////////////////////////////////////////////
2019.10.26//////////////////////////////////////////////////////////////////////////////////
todo:
.构造一个通用机制来实现类似如下功能
 以串口为例,在UI层创建一个UartObject,绑定looper中的UartHandler
 UartObject的所有接口都可在UI线程中直接调用
 UartObject内部和looper中UartHandler通讯来完成业务功能
 这样的好处是UI层使用UartObject很简单，不涉及多线程交互
 类似C#中对串口的封装接口
 这个机制可扩展在其他地方，应用很普遍

////////////////////////////////////////////////////////////////////////////////////////////
2019.10.16//////////////////////////////////////////////////////////////////////////////////
最近在思考改进log和串口工具时,想到用websocket+网页来做会比MFC/QT更加通用一些
要求网页能实现高性能的类似Scintilla编辑器的功能
发现vscode可能有参考

用了一个vscode,发现很好用
vscode是用浏览器chrome做的，支持linux,windows和macos
可编译，调试其他上所有的语言

.http header字段名称要改为大小写不敏感
 websocket判断用到了
 netty websocket client发upgrade请求时字段是小写的

.参考zlmediakit中的class StrCaseMap增加了StringCaseMap
.发现mutable有时比较好用

////////////////////////////////////////////////////////////////////////////////////////////
2019.10.08//////////////////////////////////////////////////////////////////////////////////
todo:
.为了更好的并发,可以让tcp server和client handler处于不同的looper
 client handler仅在OnCreate中绑定iocp/epoll/kqueue
.tcpserver和client handler默认为parent-child关系，但在多looper下面可以不是parent-child关系
 可以像windows hwnd parent/owner那样增加一个owner关系


////////////////////////////////////////////////////////////////////////////////////////////
2019.10.02//////////////////////////////////////////////////////////////////////////////////
UIHandler和CWnd交互
感觉不需要用继承，handler只是想post一段代码在mfc ui thread中执行,
此代码在执行时要保证mfc ui中对应的wndObject是有效的

构想如下
CWnd中创建
shared_ptr<UIHandler>	//运行在corelooper中
shared_ptr<UIProxy>	//运行在mfc ui thread中
CWnd对两者都做强引用
UIHandler对UIProxy作弱引用

CWnd可随时对UIHandler调用sendMessage和postMessage
UIHandler要和CWnd交互时，post lambda到mfc ui中执行
在lambda中
对UIProxy.lock()，有效则执行

CWnd析构时自动销毁UIProxy
如果UIHandler需要清理，可由CWnd主动进行


////////////////////////////////////////////////////////////////////////////////////////////
2019.10.01//////////////////////////////////////////////////////////////////////////////////
.需要做一个通用的机制，便于MFC中Wnd绑定corelooper中的handler
 可仿照android下的JniMainLooper来做个MfcMainLooper
WndManager管理MfcMainLooper
mfc wnd可send,post消息给handler
为避免死锁,handler只能post,不能send给
由于handler.post2Wnd需要一些清理操作，所以统一由WndManager来做

corelooper中WndHandler
mfc中HandlerWnd和WndManager
WndManager引用shared_ptr<HandlerWnd>并与和shared_ptr<WndHandler>,并维护它们的绑定关系
一个HandlerWnd可绑定多个WndHandler
WndHandler只能绑定一个HandlerWnd

HandlerWnd/WndHandler在OnDestroy时要通知WndManager撤销引用和绑定

更简单的办法是handler可以post一个lambda给WndManager在mfc主线程中调用

发现BearStudio中已做了UIHandler和MfcMainLooper,并且UIHandler能post lamba到mfc ui

考虑UIHandler和Wnd的绑定创建和解除
感觉可以做一个helper class,由mfc class继承，在helper class析构时自动解除绑定

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.29//////////////////////////////////////////////////////////////////////////////////
最近一直在重新考虑高性能日志的实现办法,发现只有共享内存能满足我的要求
windows下共享内存是CreateFileMapping
linux下共享内存shmget

在TEST_CLASS(Log)测试file mapping

TEST_METHOD(SharedMemory_Writer)
测试写数据，速度440MB/S

可以把MemoryLog集成到Handler中
Handler默认采用全局MemoryLog,在需要时可采用自定义的log
好处是LogStudio中可以非常灵活的观看特定handler的log,避免其他业务日志干扰
LogStudio可合并同一pid,同一threadId的log
每条log的time精确到us或更高

想设计一个日志类,卡在下面的问题上了：
.要支持在全局变量的构造和析构函数中打印日志（要用自己的class实现Log，不能用printf之类的） 
.不能有内存泄漏
由于全局变量析构顺序不确定，所以还没找到办法
//想到办法了,方法如下
class MemoryLog
{
public:
	MemoryLog()
	{
	}
	virtual ~MemoryLog()
	{
	}

	int mValue = 0x12345678;
};

BYTE gMemoryLogBuf[sizeof(MemoryLog)];
MemoryLog* gMemoryLog;
class MemoryLogFactory
{
public:
	MemoryLogFactory()
	{
		//在gMemoryLogBuf上主动调用MemoryLog构造函数
		void* p = (MemoryLog*)gMemoryLogBuf;
		gMemoryLog = new(p) MemoryLog();
	}
};
MemoryLogFactory gMemoryLogFactory;//确保单线程中初始化，避免竞争

//注意在visual studio中上述代码要放在如下代码之前，否则vs编译时报错
//看来是MFC内存泄漏代码不兼容c++ placement new
#ifdef _DEBUG
#define new DEBUG_NEW
#endif



熊子良说shared_ptr<Log>可解决此问题
我觉得主要缺点是要在全局变量类构造中引用shared_ptr<Log>,否则调用到析构函数时没用安全的保证Log对象的有效性,局限性比较大

全局类变量在有引起场合下是比较有用的，比如ajx command框架就用到了

todo:
.实现MemoryLog

进程间通讯：RingBuffer的性能测试
用到了linux shm
https://zhuanlan.zhihu.com/p/82371061

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.18//////////////////////////////////////////////////////////////////////////////////
E:\os\microsoft\WindowsSDK7-Samples\com\fundamentals\dcom\simple
dcom test ok
dcom可以跨PC或process使用com组件

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.17//////////////////////////////////////////////////////////////////////////////////
iocp几个可能改进的地方
corelooper目前采用的是每个iocp对应一个线程,每个socket每次投递最多一个recv和一个send,这样能极大简化框架
https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports
官网(简称msdn)上建议开多个线程来做iocp,至少和cpu个数相同
一直没理解这样的好处
按msdn上说，最高效的应该是多线程,每个socket投递多个recv,write操作
实例使用时会遇到一些问题，以tcp为例,网络服务于业务，业务一般要求有序进行
对同一socket post多个recv时，为保证recv完成时的有序处理,需要在postRecv时给recv分配唯一递增编号UIndex
{
	//加锁
	//分配UIndexA
	postRecvA
	//解锁
}
{
	//加锁
	//分配UIndexB
	postRecvB
	//解锁
}
{
	//加锁
	//分配UIndexC
	postRecvC
	//解锁
}
分配UIndex和postRecv必须在加锁后完成,否则会有竞争
当recv完成时，由于可能有多个线程在GetQueuedCompletionStatus等待，
此时windows保证GetQueuedCompletionStatus是按postRecv的次序来完成recv的
但由于线程调度等原因，业务只能根据postRecv的UIndex来保证recv数据的有序性

WSASend面临的问题更加严重,一般情况下，在多个线程中即使用加锁，也没法保证WSASend的调用顺序
而很明显，对绝大部分tcp应用来说,数据发送的有序性是基本的要求,所以归根结底，还是要在单线程中调用postWrite

没有必要迷信msdn,发现microsoft提供的一些sample其实比较垃圾,比如WindowsSDK7-Samples\netds\winsock\iocp中的例子很一般
一切以实测为准

为了保证业务层简单，避免使用锁,提高cpu cache命中率,感觉更高效的做法如下
网络socket和对应的业务worker采用各自独立的looper
每个iocp对应一个looper
accept到新socket时，绑定到当前最空闲的iocp,选择空闲iocp的策略可定制
单个socket只绑定到某一个iocp,可以post多个recv和send
业务worker也只限制在一个looper,socket收到数据后post给worker,
worker要发数据时可直接在work.looper发，也可以post给socket所在looper来发，需要实测才能知道哪种最高效
更极致的做法:iocp线程可绑定cpu,如有需要，可定时动态调整到空闲的cpu
上面说的这些细节都可以做成配置，实测一下，看哪种最有效

Riocreatecompletionqueue
https://docs.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_riocreatecompletionqueue

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.16//////////////////////////////////////////////////////////////////////////////////
.为简化流程，约定android,ios等场景下MainLooper保持一直运行，不再stop

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.15//////////////////////////////////////////////////////////////////////////////////
todo:
.研究libuv

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.14//////////////////////////////////////////////////////////////////////////////////
todo:
.把corelooper集成到vcpkg
.做一个通用的MfcMainLooper，用于在mfc app中使用corelooper功能，要达到如下效果:
 便于重用，方便集成,在app和多个dll都要用到corelooper框架的情况下，只需要创建一个MfcMainLooper
 统一通过static shared_ptr<Looper> MfcMainLooper::CreateMainLooper();来创建
 不要把项目私有功能加到MfcMainLooper中
 mfc app和dll采用各自的xxxWnd来和corelooper中的xxxHandler通讯完成业务
 xxxWnd运行在MFC主线程
 xxxHandler运行在MfcMainLooper
 提供一个规范,约定Wnd和Handler的交互，让mfc只需要和Wnd通讯，Wnd内部封装和Handler的交互
.Handler和Wnd交互细节设计
 针对具体的串口通讯业务，看是不是有必要存在定制的Handler和Wnd，有没有办法把两者或者其中一方做成通用的
 注意:为避免死锁,looper不能SendMessage到mfc
 looper只能PostMessage到mfc
 mfc可以send/postMessage到looper
 主要class:
 HandlerWnd
 WndHandler
 没有必要让每个HandlerWnd都直接和looper PostMessage的打交道,可用一个HandlerWndManager来代理此项业务
 HandlerWndManager收到消息后在mfc主线程分派消息给对应的HandlerWnd
 为简化起见，handler可以post一个lambda给HandlerWndManager在mfc主线程中调用

.MfcMainLooper的安全退出

////////////////////////////////////////////////////////////////////////////////////////////
2019.09.13//////////////////////////////////////////////////////////////////////////////////
app在使用lib应该做到只指定一个include dir,include一个头文件即可

////////////////////////////////////////////////////////////////////////////////////////////
2019.08.07//////////////////////////////////////////////////////////////////////////////////
旧版本vs工程升级后报找不到
#include "CppUnitTest.h"
的解决办法:
以vs2019为例
cd C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC>
mklink /d UnitTest Auxiliary\VS\UnitTest

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC>mklink /d UnitTest Auxiliary\VS\UnitTest
symbolic link created for UnitTest <<===>> Auxiliary\VS\UnitTest

更好的办法是:
$(VCInstallDir)Auxiliary\vs\UnitTest\include
$(VCInstallDir)Auxiliary\VS\UnitTest\lib
////////////////////////////////////////////////////////////////////////////////////////////
2019.05.18//////////////////////////////////////////////////////////////////////////////////
todo:
.handler settimer增加lambda接囗
好处:
.自定义Handler子类不用重载::OnTimer
.OnTimer中不用依次比较timerId
.不用纠结要不要调用基类::OnTimer,是先调用基类::OnTimer,还是后调用

////////////////////////////////////////////////////////////////////////////////////////////
2019.04.24//////////////////////////////////////////////////////////////////////////////////
todo:
.发现TcpClient_Windows发送数据时copy太多次了，有待改进

////////////////////////////////////////////////////////////////////////////////////////////
2019.04.21//////////////////////////////////////////////////////////////////////////////////
todo:
规划LooperPool
考虑支持如下功能
.可限定最大looper个数,为0表示不限定
.空闲时一段时间后自动清除多余的looper,可指定最小looper个数

.DNS解析改用LooperPool来做

////////////////////////////////////////////////////////////////////////////////////////////
2019.04.15//////////////////////////////////////////////////////////////////////////////////
changes:
.删除了过时的Looper::BindTLSLooper()
////////////////////////////////////////////////////////////////////////////////////////////
2019.04.14//////////////////////////////////////////////////////////////////////////////////
changes:
.改进普通thread向looper发消息
 办法是_StackLooperSendMessage采用缓存,避免每次都make_shared
//test ok,内置SmartTlsLooper

https://stackoverflow.com/questions/295120/c-mark-as-deprecated
#if defined(__GNUC__) || defined(__clang__)
#define DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement DEPRECATED for this compiler")
#define DEPRECATED
#endif

//don't use me any more
DEPRECATED void OldFunc(int a, float b);

//use me instead
void NewFunc(int a, double b);

.TestStdMutex测试了std::mutex和CriticalSection的性能
发现CriticalSection的性能是std::mutex的两倍多

.SmartTlsLooper_单元测试在退出时出现ASSERT
 原因可能是全局c++对象析构时顺序不可控引起的
 可能的解决办法,把gCSBaseHandler和SmartTlsLooperManager放在一个struct中,析构时先清理SmartTlsLooperManager对象
//已解决,用atexit来清理

////////////////////////////////////////////////////////////////////////////////////////////
2019.03.02//////////////////////////////////////////////////////////////////////////////////
changes:
.lambda+functional test ok
 https://www.cnblogs.com/ttss/p/4100917.html
.Handler增加了sendRunnable(std::function<void()> func);
 lambda+functional能更加方便的跨线程执行函数,demo如下
{
	string data = "hello";
	auto func = [=, &data]()
	{
		DV("lambda threadId=%d,obj.name=%s", ShellTool::GetCurrentThreadId(), obj->GetObjectName().c_str());
		data = "done";
		Looper::GetMainLooper()->PostQuitMessage();
	};

	obj->sendRunnable(std::bind(func));
	DV("data=%s", data.c_str());
}
在obj原生looper中执行func,能安全的访问data等本地变量


////////////////////////////////////////////////////////////////////////////////////////////
2019.03.01//////////////////////////////////////////////////////////////////////////////////
vc++ utf8 unicode转换
https://www.cnblogs.com/lidabo/p/3903616.html

////////////////////////////////////////////////////////////////////////////////////////////
2019.02.27//////////////////////////////////////////////////////////////////////////////////
changes:
.去掉了HandlerEx
 发现Handler和HandlerEx混用时，proc.xml看不到Handler子类下面的节点数据，有点混乱。
 所以把proc机制重新加在Handler中

////////////////////////////////////////////////////////////////////////////////////////////
2019.02.13//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.StringTool::Format和StringTool::AppendFormat

////////////////////////////////////////////////////////////////////////////////////////////
2019.01.19//////////////////////////////////////////////////////////////////////////////////
changes:
.增加了HttpGet和用法demo,在UnitTest Http.HttpDownload中
 
////////////////////////////////////////////////////////////////////////////////////////////
2019.01.17//////////////////////////////////////////////////////////////////////////////////
changes:
.ShellTool增加了如下接口，在ini中保存windows pos
static void SaveWindowPos(HWND hWnd, CString szWinName, IniFile& ini);
static void LoadWindowPos(HWND hWnd, CString szWinName,IniFile& ini);
作用:有时需要同时运行同一app的多个实例,需要把窗口放置在不同的位置并恢复
用注册表不方便

////////////////////////////////////////////////////////////////////////////////////////////
2019.01.16//////////////////////////////////////////////////////////////////////////////////
changes:
.增加了JniHelper::SystemClock_elapsedRealtime()
 并应用于ShellTool::GetTickCount64()，java和jni采用统一的tick，计时会比较方便

////////////////////////////////////////////////////////////////////////////////////////////
2019.01.13//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.HttpTool::ParseUrlParam中字符串解析bug
//是CStringEx改为string时api参数意义不同引起的

 
////////////////////////////////////////////////////////////////////////////////////////////
2019.01.11//////////////////////////////////////////////////////////////////////////////////
svn ignore:
*.o *.lo *.la *.al .libs *.so.[0-9]*  *.pyc *.pyo __pycache__ *.rej *~ #*# .#* .*.swp .DS_Store [Tt]humbs.db ipch Debug Bin Bin2 Release *.sdf UpgradeLog.htm  *.suo bin gen libs *.aps .vs debug release obj *.mp4 *.pdb *.ilk *.log *.d .idea  bin bin2 *.apk *.a *.pc *.db *.opendb *.ipa *.user *.cmd *.order *.symvers *.ko .tmp_versions *.mod.c *.dir ~*.docx *.tmp ~*.tmp UDebug URelease x64 .git sample-* Media build ~$* .*gradle *.lst obj
主要改动是.*gradle
它忽略.gradle文件夹，添加build.gradle


////////////////////////////////////////////////////////////////////////////////////////////
2019.01.09//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler增加了void *operator new(size_t) = delete; //disable new,please use make_shared
 即强制使用make_shared来创建Handler

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.31//////////////////////////////////////////////////////////////////////////////////
changes:
.Looper.StartRun()返回GetQuitCode()
 这样main可做到一行代码，和mfc,ios框架一样


todo:
.很多file相关代码没有考虑超过2GB的大文件情况
 目前没这个需求，后面可考虑完善
////////////////////////////////////////////////////////////////////////////////////////////
2018.12.21//////////////////////////////////////////////////////////////////////////////////
changes:
.增加了_Shortcut

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.19//////////////////////////////////////////////////////////////////////////////////
.可以把DT,ST工具上传到github,方便大家使用

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.17//////////////////////////////////////////////////////////////////////////////////
todo:
.有待研究quic
https://github.com/devsisters/libquic
////////////////////////////////////////////////////////////////////////////////////////////
2018.12.16//////////////////////////////////////////////////////////////////////////////////
.vs2017 x64下编译有warnings

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.15//////////////////////////////////////////////////////////////////////////////////
changes:
.解决了ubuntu下编译warnings,现在./c编译没有error和warning了

todo:
.cmake+gtest
 好处是vs,linux等可全部采用同一份unittest.cpp

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.11//////////////////////////////////////////////////////////////////////////////////
https://docs.microsoft.com/en-us/windows/desktop/ProcThread/using-fibers
测试了Windows协程，可以跑，但还是没体会到有什么好处

.比较好的rtmp,rtsp开源项目
E:\os\ZLMediaKit

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.10//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler可能需要增加一个OnPrepareDestructor()
 在gc中需要一个手段来通知Handler重新释放资源
//已加

////////////////////////////////////////////////////////////////////////////////////////////
2018.12.09//////////////////////////////////////////////////////////////////////////////////
markdown没有好的注释办法
https://stackoverflow.com/questions/4823468/comments-in-markdown

markdown中换行:行尾要有两个空格

changes:
.为简单起见
 long KillTimer(long& timerId);
 改为
 void KillTimer(long& timerId);


todo:
.任务池Looper
 TaskPoolLooper
 用corelooper做task pool很简单，只是需要考虑如下细节问题:
 有些异步任务是有先后关系，需要串行执行的，另一些则不关心执行顺序
////////////////////////////////////////////////////////////////////////////////////////////
2018.12.01//////////////////////////////////////////////////////////////////////////////////
.可做一个LooperWnd来标准化和演示looper和MFC的交互

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.30//////////////////////////////////////////////////////////////////////////////////
todo:
.感觉Handler要增加action chain的概念
 经常有这样的需求，一个业务的流程比较多，需要分多个步骤
 如果按常规做法，需要分散在多个地方转接处理,比如消息来转去,这样不是很清晰
 action chain的好处是集中在一处把流程制订清楚,执行时按步就班
可参考下面的项目来
https://github.com/xhawk18/promise-cpp
https://github.com/Amanieu/asyncplusplus/wiki/Parallel-algorithms

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.27//////////////////////////////////////////////////////////////////////////////////
https://github.com/alibaba/LuaViewSDK
Welcome to LuaViewSDK
LuaViewSDK is a cross-platform framework which is designed to build native, dynamic and swift user interfaces. It's based on Lua VM and chooses lua as it's script language.

Why Lua
Lua is a efficient and swift language. A single Lua VM costs 200k to 300k memorys only in iOS
Lua is widly used and it's easy to bind to third party frameworks
LuaView API is nature to native mobile developers, you guys don't have to understand what React.js or Vue.js or DOM is.


////////////////////////////////////////////////////////////////////////////////////////////
2018.11.24//////////////////////////////////////////////////////////////////////////////////
todo:
.绝大部分Handler可能不需要name和shortcut,所以tagHandlerInternalData可优化一下，做一个shared_ptr<>结构，仅在需要时创建
 这样每个tagHandlerInternalData可节省几十个字节
.dns async parser
 E:\os\acl\lib_acl\src\net\dns

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.22//////////////////////////////////////////////////////////////////////////////////
changes:
.AsyncTask又可以工作了
 增加了auto create概念,当执行Execute()时如果没有Create,则自动create
 对自动create的AsyncTask,在执行完后会由AsyncTaskLooper自动Destroy
 如果是由app主动create,则由app负责Destroy

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.18//////////////////////////////////////////////////////////////////////////////////
changes:
.tagHandlerInternalData::SetName采用std::move加速

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.16//////////////////////////////////////////////////////////////////////////////////
changes:
.受windows快捷方式启发，给Handler加上了
 int LOOPER_SAFE RegisterShortcut(const string& name, weak_ptr<Handler> obj);
 std::shared_ptr<Handler> LOOPER_SAFE Shortcut(const string& name);
 采用空的obj调用RegisterShortcut时即清除name

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.15//////////////////////////////////////////////////////////////////////////////////
.Handler多级url有时重构，可能导致多处_Object的url要做相应修改
 考虑到有的场景可能只需要一个简单的定位方法即可，
 可考虑在Looper中增加简单的name映射,不管Handler实际url在哪里，直接向current looper或者mainlooper注册
 looper采用unordered_map<string, weak_ptr<Handler>>缓存
 使用时用_SimpleObject("")
 这样在Handler url调整时,_SimpleObject不需要改变
 或者直接把此功能集成在Handler接口中
 AddWidget(const string& name,shared_ptr<Handler> obj);
 auto obj=handler.GetWidget(const string& name);
.感觉Widget不应该加上Handler中，毕竟很少有这种需求,放在Looper上面足够了
.用AddShortcut比AddWidget更形象一点
 

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.10//////////////////////////////////////////////////////////////////////////////////
想法:
在国内使用corelooper的授权方案
.按C++开发人员收年费，每人每年100元
.对在校大学生和无收入的用户完全免费
.自愿原则

todo:
.要考虑多个基于corelooper的库怎么布局
 可参考MFC 多个dll的处理
 MFC中每个extension dll都有一个app对象，然后.exe自己也有一个app,看它内部是怎么处理的
.引入lambda到corelooper
.关于帮助app测试跨looper析构Handler安全性
 可增加一个bit,试图析构时转交给另一个Looper,如果没能成功析构，再返回给原looper

------------------------------------
https://github.com/wjakob/nanogui
opengl做的ui,用cmake生成.sln,可以用vs2017编译运行，效果很不错
可用corelooper来做UI

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.06//////////////////////////////////////////////////////////////////////////////////
.这个讲iocp比较细
https://blog.csdn.net/piggyxp/article/details/6922277

////////////////////////////////////////////////////////////////////////////////////////////
2018.11.05//////////////////////////////////////////////////////////////////////////////////
changes:
.SUPER增加了using X::X;
//不仅可以用基类构造函数，还能防止跨级误用基类

#ifdef _MSC_VER
#define SUPER(X) using X::X;
#else
#define SUPER(X) using X::X; private: typedef X __super;
#endif


todo:
.Looper.PostQuitMessage感觉可以再加一个参数,string desc表示退出looper的原因,默认为空
 在退出looper时可以在log加上desc,便于调试
////////////////////////////////////////////////////////////////////////////////////////////
2018.10.30//////////////////////////////////////////////////////////////////////////////////
No toolchains found in the NDK toolchains folder for ABI with prefix: mipsel-linux-android
解决办法:
build.gradle中修改gradle版本号即可:
classpath 'com.android.tools.build:gradle:3.2.1'
https://blog.csdn.net/vocanicy/article/details/83004626

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.28//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler::GetChild中child在其他looper中时为线程不安全访问mObjectName
 改进办法，把Handler.mObjectName移入tagHandlerInternalData,并且采用gInternalDataCS来保护
//已改,Handler的GetObjectName()和SetObjectName是LOOPER_SAFE了

.为了找一个比较好的makedown编辑器，用手机号注册了简书
https://www.jianshu.com

理想中的md编辑器应该有如下功能
.左右两分页同时显示编辑和实时预览
.同步定位
.有工具栏和快捷键来做字体BIU等常用功能
.能插入图片
.能生成书签
.能导出pdf


简书md
优点:
.同步定位做的比较好

缺点:
.完全靠手写,没有BIU等字体选项


marktext:不好用

https://dillinger.io/
可以导出pdf,但没有目录

https://www.zybuluo.com
这个比较好

http://markdown.xiaoshujiang.com/
年费20,可导出pdf

https://stackedit.io/app#
https://mdp.tylingsoft.com/
它支持流程图，用的是
https://mermaidjs.github.io/

```mermaid
sequenceDiagram
    SIM868 ->> STM: 请求STM发485包数据
    STM->>485设备: 发送485包数据
    485设备 ->> STM:485设备回复包
  STM ->> SIM868:把485回复包转给SIM868

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.27//////////////////////////////////////////////////////////////////////////////////
linux在链接时指定库的路径
https://www.cnblogs.com/candl/p/7358384.html
https://www.cnblogs.com/leaven/p/6363787.html
https://www.cnblogs.com/homejim/p/8004883.html


////////////////////////////////////////////////////////////////////////////////////////////
2018.10.22//////////////////////////////////////////////////////////////////////////////////
changes:
.mChildren改用unordered_map
////////////////////////////////////////////////////////////////////////////////////////////
2018.10.17//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.HandlerBase::DumpProcData中name为空时设置为"_"
.void ProcNode::DumpString(std::string& xml)中直接采用%s
 否则mValue为空时,string格式化可能异常,现象是string中可能包含大量\0字符，具体原因未知,结果是导致字段不完整,proc.xml不能正常显示

openssl异步
https://stackoverflow.com/questions/4403816/io-completion-ports-and-openssl
https://github.com/yedf/openssl-example
https://github.com/yedf/handy-ssl
https://blog.csdn.net/xiaoqing_2014/article/details/79720913
https://blog.csdn.net/dongfuye/article/details/46819249
https://blog.csdn.net/wetest_tencent/article/details/53425198
https://www.cnblogs.com/zmqblog/p/6501930.html
https://bbs.csdn.net/topics/390495018
https://blog.csdn.net/xiaoqing_2014/article/details/79720913
https://blog.csdn.net/Ani/article/details/6408387
https://www.cnblogs.com/dongfuye/p/4121066.html
https://blog.csdn.net/u013354486/article/details/81462311

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.16//////////////////////////////////////////////////////////////////////////////////
todo:
.使用std::move提高性能
.HandlerBase::BindProcData,有时需要能把数值转为字符串描述，这样会很直观
 在绑定时最好能可选指定转换函数
enum eHangUpReason
{
	eHangUpReason_Unknown,				//未知错误
	eHangUpReason_InvalidParam,			//参数无效
	eHangUpReason_SocketConnectFail,	//socket连接失败
	eHangUpReason_PeerBusy,				//对方忙
	eHangUpReason_PeerHangUp,			//对方挂断
	eHangUpReason_LocalHangUp,			//本地主动挂断
	eHangUpReason_SiblingProcess,		//本地其他分机已接管此次呼叫
	eHangUpReason_IncomingCall,			//正在监视时，收到来电,自动退出监视状态
	eHangUpReason_TimeOut,				//超时
};
比如 eHangUpReason mHangupReason;
BindProcData(mHangupReason,"HangupReason",PhoneConnect::GetHangUpReasonDesc);
原型为const char *PhoneConnect::GetHangUpReasonDesc(eHangUpReason value)

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.13//////////////////////////////////////////////////////////////////////////////////
为什么要开源？
https://www.zhihu.com/question/33573424

Industrial-grade RPC framework used throughout Baidu, with 1,000,000+ instances and thousands kinds of services, called "baidu-rpc" inside Baidu.
https://github.com/brpc/brpc

A brpc-based server to host and proxy live streams,支持hls,rtmp
https://github.com/brpc/media-server
////////////////////////////////////////////////////////////////////////////////////////////
2018.10.11//////////////////////////////////////////////////////////////////////////////////
.去掉IniFile中的mCS
.提供demo来演示int main(int argc,char*args)中怎么处理参数和返回执行结果给main


https://blog.csdn.net/u011580175/article/details/71001796
udp成功打洞

https://github.com/Amanieu/asyncplusplus/wiki/Parallel-algorithms

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.10//////////////////////////////////////////////////////////////////////////////////
android studio 采用clang来编译jni
可通过预定义宏__clang__来区分android编译环境

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.09//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.StringTool::Format中vsnprintf返回值大于bufBytes时要重新申请buffer

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.08//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler::OnDestroy有可能被多次调用
//已解决,增加了mDestroyCalled

////////////////////////////////////////////////////////////////////////////////////////////
2018.10.01//////////////////////////////////////////////////////////////////////////////////
.开源项目handy中有一个timer的实现很简单，有待研究
 测试代码在:
 TEST_METHOD(TestHandy)

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.26//////////////////////////////////////////////////////////////////////////////////
https://blog.csdn.net/cjmqas/article/details/79282847
利用vcpkg轻松集成开源第三方库

有了vcpkg,能很轻松的用vs编译支持cmake的开源项目了
比如evpp等


todo:
.Handler在析构时post消息给looper
 这样looper在quit时就不需要settimer来定时检测是否可能quit looper了
 只有当Handler的parent为looper时才需要这样做
 如果handler的parent也是handler,则不需要post给looper


////////////////////////////////////////////////////////////////////////////////////////////
2018.09.25//////////////////////////////////////////////////////////////////////////////////
android studio cmake
可以用CMAKE_BUILD_TYPE来区分Debug和Release
可以用ANDROID_ABI区分abi
https://developer.android.google.cn/ndk/guides/cmake#options

target_link_libraries( # Specifies the target library.
                       ${TARGET_NAME}

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib}
                       ${PROJECT_SOURCE_DIR}/libs/cloudp2p/${ANDROID_ABI}/libPPCS_API.a
                       ${PROJECT_SOURCE_DIR}/../../libcorelooper.as/libcorelooper/build/intermediates/cmake/${CMAKE_BUILD_TYPE}/obj/${ANDROID_ABI}/libcorelooper.so
                       )
////////////////////////////////////////////////////////////////////////////////////////////
2018.09.24//////////////////////////////////////////////////////////////////////////////////
.发现这个项目和corelooper比较像,它是受android looper/handler启发
https://github.com/Himmele/Mindroid.cpp
https://github.com/Himmele/Mindroid.ecpp


//Handler(std::shared_ptr<Looper> looper);
//说明:不支持通过构造函数创建跨looper的Handler,原因见todo.txt 2018.08.07
//创建跨looper的Handler可使用:
//auto obj=make_shared<Handler>();
//looper->AddChild(obj);
//或者obj->Create(looper);
//这种方式更加安全一些，在调用AddChild/Create之前可在当前looper操作obj,比如设置初始化参数

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.23//////////////////////////////////////////////////////////////////////////////////
todo:
.send,post可能失败，所以参数中的make_shared<struct>不能用mSelfRef指向自己来保活
 要由corelooper框架统一来做

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.22//////////////////////////////////////////////////////////////////////////////////
changes:
.在移植libcorelooper到android时,clang++报socket bind和stl bind冲突
 看来不能在.h中用using namespace std;

在Handler的.h中用如下代码，就能在子类中直接使用std中的这些功能了
namespace Bear {
namespace Core
{

using std::list;
using std::string;
using std::map;
using std::vector;
using std::shared_ptr;
using std::make_shared;
using std::weak_ptr;
using std::enable_shared_from_this;
using std::dynamic_pointer_cast;


changes:
.libcorelooper.as可以在android平板上运行了
https://developer.android.google.cn/studio/debug/


todo:
.looper的timer精度有待改进,1000ms的timer打印如下
09-22 15:16:30.610 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0136](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:31.610 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0137](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:32.609 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0138](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:33.609 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0139](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:34.619 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0140](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:35.619 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0141](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
09-22 15:16:36.620 25709-25724/com.jjyip.libcorelooper I/Bear/JNI: [OnTimer,idx=0142](D:\corelooper\projects\libcorelooper.as\app\src\main\cpp\native-lib.cpp:24)
即有漂移，不是精确的1000ms

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.21//////////////////////////////////////////////////////////////////////////////////
changes:
.改进了Handler::BindMessage,可以直接在class声明中分配和绑定
class Activity
{
const UINT mMessageStart = BindMessage(&Activity::OnStart);
const UINT mMessageResume = BindMessage(&Activity::OnResume);
}

BindMessage的好处是可以让子类不需要重载OnMessage,直接指定message的处理proc

.BlockLooper创建一个同名Handler,并添加到父looper
//已加

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.20//////////////////////////////////////////////////////////////////////////////////
changes:
.Looper和Handler分别增加了mTickStartQuit和mTickDestroy
 用来检查哪个环节有阻塞

.发现如下代码会memory leak
 {
	auto obj = make_shared<TcpServer>();
	obj->StartServer(8081);
 }
//已处理，最简单的办法是强制要求Create()然后才能StartServer

todo:
.发现TcpServer析构需要约1秒，原因待查
.TimerManager优化
 记住上次tick和版本号
 每次timer有变动时版本号+1
 当TimerManager::ProcessTimer中tick和version都和上次相同时，说明和上次调用完全相同，直接返回上次的结果
 这样可省下大量的重复检测
 .版本号没有变化时，可直接用缓存tick减去当前tick,不需要每次都遍历时间轮

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.19//////////////////////////////////////////////////////////////////////////////////
.增加类android message
 完善//仿android message class Message
 增加Message类，用来统一处理消息投递失败时有mSelfRef的处理
	比如在Handler::sendRunnable中
	auto info = make_shared<tagDelayedRunnable>();
	info->mHandler = shared_from_this();
	info->mRunnable = obj;
	info->mSelfRef = info;
	在消息投递失败时，现在是要手动重置mSelfRef,否则会导致memory leak
 采用Message类投递的消息，是在Handler::handleMessage(const Message& msg)中处理的
 内部是采用OnMessage实现的
.bearcore增加了HttpGet,HttpPost,SimpleConnectHandler,记得移植过来
.如有必要，可强制在构造Handler时就指定parent,默认parent为nullptr,表示parent为当前looper
.集成BaseLooper中的JniLooper,用来解决android死锁问题
.打算做个libcorenet,把net相关功能从libcorelooper独立出来
.sendMessage,postMessage在looper exiting时的失败处理
 怎么区分是投递消息失败，还是消息执行返回值
 怎么清理投递失败时的WPARAM,LPARAM资源释放
.重构proc机制

--------------------------------------------------------------
Handler注意事项
.有时上级用shared_ptr指向子object会比较方便，
 注意要在parent OnDestroy中清空这个shared_ptr,否则由于循环引用导致对象一直存在


////////////////////////////////////////////////////////////////////////////////////////////
2018.09.18//////////////////////////////////////////////////////////////////////////////////
changes:
.删除了looper的InitInstance和ExitInstance，和handler一样统一用OnCreate和OnDestroy
.增加接口来给message id添加message handler proc,这样就不需要子类重载OnMessage了
//已加Handler::BindMessage
 增加了BIND_MESSAGE,用来简化调用BindMessage
 说明:BindMessage和BIND_MESSAGE只应该并且只能用来处理用户自定义的消息(即messageId必须<BM_NULL)
 不支持能同一messageId多个bind,只有最后bind的那个entry会生效
.Handler提供接口来自动分配message id
 增加了AllocMessageId(),可以在Handler子类的构造函数中调用本接口
  或者直接初始化
		class Handler2 :public Handler
		{
		public:
			UINT mTestMessageId = AllocMessageId();
		};

  主要作用是解决如下问题:
  如果父类和子类都采用手工指定的固定messageId,特别是在看不到父类源码的情况下,则可能出现id重复而出现消息没能按预期分派,
  比如说父类.cpp中定义了BM_TEST=100,恰好子类也定义了BM_OTHER=100,就会出现冲突,只有一方能正确收到100的消息
  项目越大，class tree的级数越多，出现message id冲突的可能性越大
  用AllocMessageId()可解决此问题,它返回一个空闲的messageId,避免自定义的id同上级parent的id冲突
  AllocMessageId()分析的message id是针对单个handler实例的,
  messageId属于有限制的资源，没有提供并且也不需要FreeMessageId()接口,
  corelooper保证AllocMessageId()至少可成功分配1万个messageId,如果不够用，请优化app对message id的用法

.增加类android message
 完善//仿android message class Message

////////////////////////////////////////////////////////////////////////////////////////////
2018.09.10//////////////////////////////////////////////////////////////////////////////////
.增加Message类，用来统一处理消息投递失败时有mSelfRef的处理
	比如在Handler::sendRunnable中
	auto info = make_shared<tagDelayedRunnable>();
	info->mHandler = shared_from_this();
	info->mRunnable = obj;
	info->mSelfRef = info;
	在消息投递失败时，现在是要手动重置mSelfRef,否则会导致memory leak
.采用Message类投递的消息，是在Handler::handleMessage(const Message& msg)中处理的
 内部是采用OnMessage实现的

////////////////////////////////////////////////////////////////////////////////////////////
2018.08.08//////////////////////////////////////////////////////////////////////////////////
changes:
.实现了Looper的Create()和Destroy()
 Create相当于Start()
 Destroy()相当于PostQuitMessage(0)


////////////////////////////////////////////////////////////////////////////////////////////
2018.08.07//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler(Looper)可能不太适合，用looper->AddChild更加方便一些
auto obj=make_shared<Handler>(looper);
obj->Create(looper);
或者
looper->AddChild(obj);
这样的用法有点重复了,looper
Handler构造函数中不能使用shared_from_this(),用Handler(Looper)没法一步到位,仍然需要显式调用Create或者AddChild
所以规定按如下用法
auto obj=make_shared<Handler>();
obj->Create(looper);
或者
looper->AddChild(obj);

.为了支持在Create/AddChild时转移到新的Looper，必须保证在当前looper中没有pending message,
所以必须限制在Create之前不能sendMessage/postMessage,也不能SetTimer
//已加

.tagHandlerInternalData增加了mInternalDataCS,用来同步AddChild
 是为了防止恶意场景:多个不同的looper对同一handler调用AddChild,会有竞争
 为了这一个极端情况，每个tagHandlerInternalData增加了56字节,代价有点大
 //已改进为gInternalDataCS,总共只需要一个,不会造成性能瓶颈

.bug fixed:
.在LooperImpl::_WorkThread()运行之前就要对mCrated=true,否则会有竞争

-------------------------------------------------------
今天vps又被墙了,感觉这vps是没法用了
现在可以通过帝联提供的远程工具直接连接
C:\Program Files (x86)\Microsoft\Remote Desktop Connection Manager\RDCMan.exe
要先在帝联控制面板上填写当前的wan ip
然后用RDCMan.exe连接
在RDCMan远程登录时按Ctrl+Alt+End相当于Ctrl+Alt+Delete

////////////////////////////////////////////////////////////////////////////////////////////
2018.08.06//////////////////////////////////////////////////////////////////////////////////
.可考虑用template来创建cross looper handler
	template T CreateHandler<T>()
	{
		auto obj = make_shared<T>(shared_from_this());
		shared_from_this()->AddChild(obj);
		if(obj.IsCreated())
			return obj;
		return nullptr;
	}
//已加，但这样不是太灵活，创建obj后没法设置初始化参数

////////////////////////////////////////////////////////////////////////////////////////////
2018.08.05//////////////////////////////////////////////////////////////////////////////////
typescript感觉是个趋势,可学习一下，能做微信小程序，有demo
http://www.typescriptlang.org

	.可考虑让Handler.Create支持跨looper创建Handler
	 android Handler是支持这种用法的，直接在构造时指定looper
	 如有必要,可考虑增加限制，必须在Handler.Create之后才能sendMessage/postMessage
	可考虑去掉显式调用Handler.Create,而是直接由Handler构造函数用postMessage来自动触发.Create
	不能在Handler构造函数中直接触发，原因是此时Handler子类还没完成构造
	Handler.Destroy()仍然需要由用户显式调用

	 Handler运行和布局所属的looper可考虑独立出来
	AddChild(make_shared<Worker>(WorkLooper));

	.发现没有办法来全自动触发Handler.Create,一个场景如下
	{
		auto obj = make_shared<Worker>(looper);
	}
	在构造函数中没法直接用shared_from_this(),导致没有办法对Worker作引用，随后obj就析构了,所以没法自动.Create
//上述问题已解决,Handler在Create时才绑定looper

.bearcore增加了HttpGet,HttpPost,SimpleConnectHandler,记得移植过来
.如有必要，可强制在构造Handler时就指定parent,默认parent为nullptr,表示parent为当前looper
.集成BaseLooper中的JniLooper,用来解决android死锁问题
.打算做个libcorenet,把net相关功能从libcorelooper独立出来
.sendMessage,postMessage在looper exiting时的失败处理
 怎么区分是投递消息失败，还是消息执行返回值
 怎么清理投递失败时的WPARAM,LPARAM资源释放
.重构proc机制

////////////////////////////////////////////////////////////////////////////////////////////
2018.08.03//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.TestManyLooper 1000个looper时，经常在析构looper中出现TimerManager crash
//SetTimer/SetTimerEx/KillTimer在Handler和Looper的实现是不同的，所以在tagHandlerInternalData要区分
发现一直有此问题，并不是重构Handler引起的
//已解决，tagHandlerInternalData在析构时要判断是否为looper,仅在为普通handler时才调用RemoveAllTimer()
	if (!mIsLooper)
	{
		RemoveAllTimer();
	}

looper的timer可自动销毁，不需要显示删除


////////////////////////////////////////////////////////////////////////////////////////////
2018.08.01//////////////////////////////////////////////////////////////////////////////////
.精简Handler中的接口，把不需要放在Handler中的接口全部移到tagHandlerInternalData中
 理想情况下,Handler只保留对用户来说有用的接口,所有的xxx_Impl都移入tagHandlerInternalData

Async++ concurrency framework for C++11
https://github.com/Amanieu/asyncplusplus
vs 工程在E:\os\asyncplusplus\async
https://docs.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime

Async++感觉会比较有用,拿来做task dependency任务流执行业务会很直观
发现vs2013编译Async++有些用法会报错，需要vs2015才行

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.07.31/////////////////////////////////////////////////////////////////////////////////////////////
Async++ concurrency framework for C++11
https://github.com/Amanieu/asyncplusplus
vs 工程在E:\os\asyncplusplus\async
https://docs.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.30//////////////////////////////////////////////////////////////////////////////////
E:\os\revolver
插入100万个定时事件耗时978MS
//已测试Timer_SetTimerPerformance,在realease x64下run test,100万个SetTimer只需要764ms左右

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.29//////////////////////////////////////////////////////////////////////////////////
.把Handler,Looper中一些成员变量用shared_ptr<struct tagInterData>封装起来
 用户不需要知道这些细节
 也可更好的保护技术细节
//已加

changes:
handler,looper成员用对外不可见的shared_ptr struct 封装
这样还有个好处，handler和struct 生命周期独立，handler timer由struct 转发，
looper.gc中可避免过早删除timer和delayed runnable
//已解决,在tagLooperInternalData::gc()中做了处理

.Handler增加了tagHandlerInternalData好处很多
 CoreLooper尽力保证Handler在原生looper中析构，但不能100%保证
 由于tagHandlerInternalData对外不可见,
 CoreLooper可100%保证正常使用时在其handler的原生looper中析构tagHandlerInternalData
 正常使用是指在原生looper中create
 如果make_shared<Handler>()后直接返回给另一looper并置nullptr,则仍然会跨looper析构tagHandlerInternalData

上周说的跨looper析构handler的问题解决了
corelooper尽力保证handler在原生looper中析构，但即使跨looper析构也不会引起问题
实际正常使用时handler跨looper析构的几率基本为0

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.28//////////////////////////////////////////////////////////////////////////////////
优化Handler大小
////////////////////////////////////////////////////////////////////////////////////////////
2018.07.27//////////////////////////////////////////////////////////////////////////////////
关于跨looper定时weak_ptr lock()
LooperImpl::gc()
//这里有竞争关系，可能导致在其他thread中析构handler,描述如下:
//当上面的use_count=1时运行到此，然后cpu切换到另一thread,在另一thread中weakptr lock得到shared_ptr
//然后切换到本thread执行items[key] = nullptr;
//然后再切换到另一thread析构shared_ptr才再切回到本thread
//感觉这种时序只在理论上存在，实际上基本不会遇到
已做了处理，在TimerManager中当检测到Handler已destroy时，仅在mDestroyedHandlers中存在此handler才允许触发OnTimer
这样可保证跨looper析构handler之后不会触发已失效的handler.OnTimer,从而避免crash
另外handler析构函数中也仅在原生looper中才RemoveAllTimer()
可认为基本解决了此问题

changes:
.LooperImpl::SetTimerEx限制了Handler只能在Create之后SetTimer
.增加了_CONFIG_TEST_CROSS_LOOPER_WEAK_PTR_LOCK,专门测试跨looper析构hanlder的场景
改动如下
.handler调用Destroy()之后在Looper::gc()中发现use_count()==1,则调用handler.RemoveAllTimer(),用来防止跨looper析构handler后timer导致crash
 这样handler.Destroy()之后,框架随时可能删除所有timer,postDelayedRunnable的runnable也可能被清除


CoreLooper框架改动
.对于调用了handler.Create()后的handler,CoreLooper基本可以保证Handler在原生looper在析构，但不是100%保证
 在验证稳定性时可精心构造出此场景,由此CoreLooper保证Handler在跨looper析构时不会出现异常
 实际运行中跨looper析构handler的几率可忽略不计
 强烈建议用户把清理操作放在OnDestroy()中就能保证不出现异常,OnDestroy()始终是在handler原生looper中调用的
.之前的设计是Handler可以在构造函数中调用SetTimer,KillTimer
 现在为了让Handler和Looper更加统一,限制仅在Handler.OnCreate()里面或者之后才能成功调用SetTimer
 postDelayedRunnable内部用到了SetTimer,所以也有这个限制

.如有必要，可强制在构造Handler时就指定parent,默认parent为nullptr,表示parent为当前looper

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.18//////////////////////////////////////////////////////////////////////////////////
关于corelooper和其他语言对接的想法
可通过server,client类似RPC来做，采用local socket,性能一般来说是足够的

.流行的RPC框架
google的gRPC E:\os\rpc\grpc
facebook的thrift, E:\os\rpc\thrift
发现thrift中有
class Runnable {

public:
  virtual ~Runnable(){};
  virtual void run() = 0;
//看来英雄所见略同!

.可参照android文档来编写corelooper文档
 copy网页内容到word可得到样式


////////////////////////////////////////////////////////////////////////////////////////////
2018.07.17//////////////////////////////////////////////////////////////////////////////////
changes:
.测试跨looper创建handler
 在looperA中创建handler,加到looperB中的handlerParent
//不支持,为简化起见，限制如下
 handler和parentHandler都不是looper时，handler和parentHandler必须属于同一looper中

changes:
.创建Handler但不调用.Create,handler仍然可以接收消息
//pass

.测试多次Create,AddChild,destroy同一handler
//pass

.在looperA中创建handler,加到looperB
//pass

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.07.16/////////////////////////////////////////////////////////////////////////////////////////////
ffmpeg Nvidia硬件加速总结
https://blog.csdn.net/LeoChen1983/article/details/72730802
////////////////////////////////////////////////////////////////////////////////////////////
2018.07.15//////////////////////////////////////////////////////////////////////////////////
注意timer原型
void OnTimer(long id);
如果弄成void OnTimer(UINT id),在ubuntu下编译能通用，并且能在里面调用__super::OnTimer(id);但OnTimer不会被触发

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.07.14/////////////////////////////////////////////////////////////////////////////////////////////
.集成BaseLooper中的JniLooper,用来解决android死锁问题

.android播放声音时点静音容易死锁
 感觉和jni call有关,增加了JniTracker来验证这一点
 发现c++在调用jni CallVoidMethod发消息给java时，java又调用jni api并用looper::sendMessage等待c++处理结果
//解决办法,增加一个JniLooper,专门用来发消息给java,
 其他looper都postMessage给JniLooper
//已增加了postRunnable接口,接口能正常使用

.CameraDevice_AudioCB_Android::onRecvAudio,发现在JniLooper发audio给android时，video画面很容易卡死
 每次audio有320 bytes
//已解决,采用JniLooper转发

 MainLooper_EPMaster::OnMessage中做了优化，仅在初始化时AttachCurrentThread,结束时DetachCurrentThread
 但仍然有死锁风险
//已解决,采用JniLooper转发
 
////////////////////////////////////////////////////////////////////////////////////////////
2018.07.13//////////////////////////////////////////////////////////////////////////////////
changes:
.把需要公开的.h单独存放

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.12//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler.mTimerMap改进
 从map改为unordered_map
 map采用red-black tree
	插入: O(logN)
	查看:O(logN)
	删除:O(logN)
 unordered_map采用hash表:
	插入:O(1)，最坏情况O(N)
	查看:O(1)，最坏情况O(N)
	删除:O(1)，最坏情况O(N)
一般来说海量应用时是Handler的个数很多,而每个Handler的timer只有几个
所以Handler.mTimerMap在SetTimer和KillTimer时复杂度可认为是O(1)
执行OnTimer是不需要访问mTimerMap的

.去掉了BM_TIMER
 是直接调用OnTimer的

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.11//////////////////////////////////////////////////////////////////////////////////
.bearcore增加了HttpGet,HttpPost,SimpleConnectHandler,记得移植过来

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.07.10/////////////////////////////////////////////////////////////////////////////////////////////
github.com上很多开源文档采用.md文件
在chrome查看.md文件
搜索安装Markdown Reader,要勾上"允许访问文件网址"
////////////////////////////////////////////////////////////////////////////////////////////
2018.07.04//////////////////////////////////////////////////////////////////////////////////
changes:
.为了能在Handler()普通子类构造函数中调用SetTimer和KillTimer
 SetTimer和KillTimer内部不用使用shared_from_this()
 注意:不支持在Looper子类的构造函数中直接SetTimer/KillTimer,必须start looper后才能调用
//已改,test ok

.打算做个libcorenet,把net相关功能从libcorelooper独立出来
.sendMessage,postMessage在looper exiting时的失败处理
 怎么区分是投递消息失败，还是消息执行返回值
 怎么清理投递失败时的WPARAM,LPARAM资源释放

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.03//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.SendMessageSpeed很容易出现阻死
 原因是looper已退出，但还阻塞在sendMessage中
 Looper目前存在缺陷，要改进
 只要looper没有析构，就要进行响应消息
已过时			//LooperImpl::CanQuitLooperNow()中增加了判断shared_from_this().use_count()
已过时			仅在外界没有引用looper时才允许退出looper线程,
已过时			有个漏洞:
已过时			如果外界保持weak_ptr<Looper>,并且定时lock(),则仍有可能竞争!
.解决办法
 在加锁后，mMessageList.push_back之前判断mLooperRunning
 在LooperImpl::Run()中加锁后确保mMessageList为null再设置mLooperRunning=false,防止第三方sendMessage,postMessage,这样就消除了竞争
缺陷:此情形下sendMessage,postMessage失败可能导致WPARAM,LPARAM的资源泄漏,几率极小并且只在looper发生，普通handler不会发生,所以可不处理


////////////////////////////////////////////////////////////////////////////////////////////
2018.07.02//////////////////////////////////////////////////////////////////////////////////
changes:
.Handler增加了cancelRunnable
 可以取消postRunnable和postDelayedRunnable提交的Runnable
 sendRunnable提交的Runnable是同步执行的，不能取消

////////////////////////////////////////////////////////////////////////////////////////////
2018.07.01//////////////////////////////////////////////////////////////////////////////////
用我手机注册了zhihu
user:13544178846
sn:xxy2012


.Android的Handler postDelayedXXX支持取消，是遍历MessageQueue实现的
 这样性能不高
 CoreLooper.Handler不提供cancel功能,可用其他方法普通来实现
 比如Runnable子类增加一个bool mCancel,在Run()执行时mCancel为true则取消
 效果基本相同

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.30//////////////////////////////////////////////////////////////////////////////////
.looper引入了gc()机制，可以保证Handler在原生looper中析构，这大大简化了逻辑,好处多多
 关于handler可能稍有延时析构，可能导致某些资源不能及时释放的解决办法:
 请提供单独的资源释放接口,不要依赖Handler子类的析构函数

.
AddChild(make_shared<WorkHandler>());
相当于
make_shared<WorkHandler>()->Create(shared_from_this());

在AS中做了测试，Activity即使onDestroy了，还是能响应timer消息
Core Handler最好也这样做,即create,destroy状态只是框架为方便使用而制订的一套机制，不影响对象的生命周期。
//已采用Looper.gc(),现在Handler destroy之后timer也能正常工作了,和android行为一致

.Handler和NativeHandler分离
 问题的根源在于，怎么保证handler在原生looper中析构
想法:
handler destroy时,原生looper对handler保持一个shared_ptr到mDestroyedHandlers
原生looper定时check mDestroyedHandlers,当看到use_count为1时清除它
为避免其他looper weak_ptr竞争
原生looper的做法如下
void CheckFreeHandler()
{
	//遍历mDestroyedHandlers
	{
		weak_ptr<Handler> obj=handler;
		handler=nullptr;

		auto item=obj.lock();
		if(item!=nullptr)
		{
			//说明其他地方还在使用,所以item要重新加入mDestroyedHandlers
		}
	}
}

相当于looper增加垃圾回收机制
looper.gc();
mDestroyedHandlers非空时,looper每秒调用一次gc();
gc()为跨looper安全，其他looper可主动调用
//test ok,效果非常好

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.29//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.StringTool::Format buffer过小时处理有bug

.为了支持CrossLooperDestroyHandler,构想如下
 可引入kernelHandler,把handler做成空壳，在析构handler时postMessage给绑定的KernelHandler
 框架在触发timer,socket事件之前都对handler保持一个引用，保证handler在响应期间一直有效
 这样handler可直接mSelfRef=nullptr;不需要PostDispose(mSelfRef);
	//实现办法
	对外提供Handler对象
	在内部，每个Handler对应一个NativeHandler
	NativeHandler对Handler保持weak_ptr mBuddy;
	NativeHandler对外界不可见,始终停留在原生looper中
	Handler对外可见,可跨looper使用,
	Handler在原生looper中的业务由NativeHandler代理，每次NativeHandler都mBuddy.lock()，然后才调用
	当Handler析构时postMessage给NativeHandler,NativeHandler自行销毁
	.当destroy之后，不再允许进行网络操作
	 为提高性能,iocp/epoll没有对handler保留引用，而是直接采用raw pointer
	 即需要mSelfRef有效才能安全的进行网络IO,否则在CrossLooperDestroyHandler场景下会crash
	//改进:net io也可由NativeHandler来代理
	借用Windows OS概念
	Handler是应用层对象
	NativeHandler相当于Handler对应的内核对象
	Looper由于可以不需要NativeHandler
//已采用更好的办法,采用Looper.gc()中解决了

.Create,Destroy对称
 只能在原生looper中Create
 为方便使用，可以跨looper调用Destroy
  
.CheckWeakPtrLooperSafe
//结果:经测试确认，一旦执行到object的析构，在其他looper中weak_ptr lock会返回nullptr


////////////////////////////////////////////////////////////////////////////////////////////
2018.06.28/////////////////////////////////////////////////////////////////////////////////
changes:
.SetTimer,KillTimer去掉了LOOPER_SAFE标记
 这两个接口没有必要做成looper安全的
.Handler::OnDestroy()中不再调用RemoveAllTimer();
 destroy和timer没有相关性,create,destroy只是为了方便初始化和反初始化而做的一种机制
 但实际上还是以c++ object life time为准,所以destroy之后object应该照样能正常工作
.TimerManager::ProcessTimeOut中在调用Handler::OnTimer时增加了引用
 可保证OnTimer期间handler一直有效
	{
		auto obj = node->mHandler->shared_from_this();//保证在调用OnTimer时node->mHandler一直有效
		node->mHandler->OnTimer(node->mTimerId);
	}
 如果不做此保证，则OnTimer途中handler可能失效，很容易导致app crash

.发现vs unit test不能检测memory leak
//发现是可以检测memory leak的,要添加如下几行，
#ifdef _MSC_VER_DEBUG
#define new DEBUG_NEW
#endif
不添加的话，也能检测到，但定位不到代码行,添加后可以定位到代码行
memory leak在Output>Debug中
消息比较多，要向上拉才能看的到

https://stackoverflow.com/questions/8544090/detected-memory-leaks
Detected memory leaks!
Dumping objects ->
{9554} normal block at 0x003CDCC0, 44 bytes long.
Data: < e n d > 20 C1 65 01 01 00 00 00 6E 00 00 00 9C CE 64 01
{9553} normal block at 0x003CDB58, 8 bytes long.
Data: < D e < > 44 BD 65 01 C0 DC 3C 00
内存泄漏调试利器:
_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
_CrtSetBreakAlloc(9554);
_CrtSetBreakAlloc(9553);
这样第9554分配内存时vs会自动定位call stack

.在vs2017中long在x64下仍然是32bit,有时需要在OnMessage返回指针，指针是64bit,无法用long表示
 所以有些api需要修改type,比如
 sendMessage
 postMessage
 OnMessage
 dispatchMessage


.SetTimer改进
 BaseHandler的timer接口可以改进一下
现在是
long BaseHandler::SetTimer(long& timerId, UINT interval)
void BaseHandler::KillTimer(long& timerId);
void OnTimer(UINT timerId);
这样存在一个问题:timerId由class自行指定，而子类有可能不知道基类的内部实现
当基类和子类恰好选用了相同的timerId来做不同的业务，就会导致bug
改进办法:可改为
long SetTimer(int ms);
void KillTimer(long timerId);
void OnTimer(long timerId);

约定0是无效timerId
每个类都有成员变量来缓存timerId,比如
long mTimerKeepAlive=0;
long mTimerCheckFrame=0;

mTimerTest=SetTimer(1000);
mTimerCheckFrame=SetTimer(20);

在OnTimer(long timerId)中
if(timerId == mTimerTest )
{
}
else if(timerId == mTimerCheckFrame)
{
}
这样的好处是避免手工分配固定timerId,基类和子类的timerId绝对不会重复导致冲突
//已加，测试效果良好，再也不用担心timerId冲突了

.考虑跨looper析构handler时的处理
//已在06.30采用gc解决

.looper中移除mIniFile,大分部looper是不需要ini的
//done

.增加了
Handler::PostRunnable(shared_ptr<Runnable> obj)
Handler::SendRunnable(shared_ptr<Runnable> obj)
//test ok

.重构proc机制，优化Handler大小
.Looper可以像PlatformServer工程中的MbedTls和MbedTls_Impl那样封装，好处是隐藏细节实现
.test StringTool::ExtractSubString
 HttpTool::ParseUrlParam

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.06.27/////////////////////////////////////////////////////////////////////////////////////////////
.用vue做的，支持back的流行网页框架
https://github.com/PanJiaChen/vue-element-admin

.基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用
https://github.com/bailicangdu/vue2-elm

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.26/////////////////////////////////////////////////////////////////////////////////
changes:
.BaseObject改名为Object
.corelooper改为Looper
.BaseHandler改为Handler

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.23/////////////////////////////////////////////////////////////////////////////////
.baselooper打算改名为CoreLooper,这样更有意义一些

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.12/////////////////////////////////////////////////////////////////////////////////
.Looper可以像PlatformServer工程中的MbedTls和MbedTls_Impl那样封装，好处是隐藏细节实现

--------------------------------------------------------------------------
.c++也是可以像java那样，在函数体内定义并创建class,能正常调用运行
	if (0)
	{
		class HikLooper:public corelooper
		{
		public:
			void OnCreate()
			{
				SetTimer(0, 100);
			}

			void OnTimer(UINT id)
			{
				if (id == 0)
				{
					static int idx = -1;
					++idx;
					DV("OnTimer,idx=%04d", idx);
					if (idx == 50)
					{
						PostQuitMessage();
					}
					return;
				}
				__super::OnTimer(id);
			}
		};

		auto obj = make_shared<HikLooper>();
		obj->Start();

		return 0;
	}

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.06.11/////////////////////////////////////////////////////////////////////////////////////////////
corelooper和Windows SendMessage性能比较
release版 send message 100w次

.同一线程内
 corelooper占用约200ms,即500w/s
 windows占用约300ms,即333w/s

.跨线程send message
 corelooper约6.3s,即15.8w/s
 windows约4.4s,即22.7w/s


svn filter:
*.o *.lo *.la *.al .libs *.so.[0-9]*  *.pyc *.pyo __pycache__ *.rej *~ #*# .#* .*.swp .DS_Store [Tt]humbs.db ipch Debug Bin Bin2 Release *.sdf UpgradeLog.htm  *.suo bin gen libs *.aps .vs debug release obj *.mp4 *.pdb *.ilk *.log *.d build .idea .gradle bin bin2 armeabi *.apk *.a *.pc *.db *.opendb *.aar *.so *.ipa *.user *.cmd *.order *.symvers *.ko .tmp_versions *.mod.c *.dir ~*.docx *.tmp ~*.tmp UDebug URelease x64 .git sample-* Media *.iml build build.*

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.09/////////////////////////////////////////////////////////////////////////////////
E:\os\flamingo\flamingo20180407\flamingoserver
class LogStream比较好，能用<<输出日志,这样可避免format %s类型不匹配导致crash

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.07/////////////////////////////////////////////////////////////////////////////////
.考虑采用json来传数据
 E:\os\tencent\rapidjson\build\RapidJSON.sln
 可编译运行
 http://rapidjson.org/
//在tests测试ok,rapidjson只包括头文件，能很方便的使用
zhihu上面说rapidjson可能有memory leak,并且接口不好用
//在tests中测试了https://github.com/nlohmann/json,这个明显好用很多,性能比rapidson差一点，够用了
在TEST_CLASS(NlohmannJson)测试ok,能很方便的生成和解析json
FileEx::Dump(o.dump(4), "d:/t.json");//dump(4)是pretty格式，indent为4个空格,效果很好!
--------------------------------------------------------------------------------------------

E:\os\tencent\rapidjson\test\unittest\unittest.cpp
有回避gtest memory leaks的办法:
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);

    std::cout << "RapidJSON v" << RAPIDJSON_VERSION_STRING << std::endl;

#if _MSC_VER
    _CrtMemState memoryState = { 0 };
    _CrtMemCheckpoint(&memoryState);
    //_CrtSetBreakAlloc(X);
    //void *testWhetherMemoryLeakDetectionWorks = malloc(1);
#endif

    int ret = RUN_ALL_TESTS();

#if _MSC_VER
    // Current gtest constantly leak 2 blocks at exit
    _CrtMemDumpAllObjectsSince(&memoryState);
#endif
    return ret;
}

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.06/////////////////////////////////////////////////////////////////////////////////
changes:
.增加了顶级namespace Bear
.多级namespace的好处是互不干扰
 有时在实现一些功能时，要做一些帮助类,给帮助类取名时，如果不用namespace,类名很容易和其他模块同名
 有了多级namespace就不存在此问题了

.corelooper中每一个class都要增加详细的test实例

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.05/////////////////////////////////////////////////////////////////////////////////
感觉可以采用多级namespace来模仿android class tree
比如
Net::Ftp
Net::Http
	Net::Http::HttpClient
	Net::Http::HttpServer
Net::Rtsp
Net::Tftp

想定义几个macro,这样更改namespace容易一些
#define _BEGIN_NS_HTTP	namespace Bear {\
namespace Net{\
namespace Http{

#define _END_NS_HTTP	}}}

_BEGIN_NS_HTTP
class HttpClient
{
public:
	HttpClient()
	{
		DV("%s", __func__);
	}
};
_END_NS_HTTP

经测试发现vs能编译通过，但class view中不展示HttpClient

////////////////////////////////////////////////////////////////////////////////////////////
2018.06.02/////////////////////////////////////////////////////////////////////////////////
.test StringTool::ExtractSubString
 HttpTool::ParseUrlParam

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.06.01/////////////////////////////////////////////////////////////////////////////////////////////
cmake+gtest test ok
D:\bear\board\demo\stud

指定编译器的新方法
在./c.sh中
export CC=/opt/hisi-linux/x86-arm/arm-hisiv300-linux/bin/arm-hisiv300-linux-uclibcgnueabi-gcc
export CXX=/opt/hisi-linux/x86-arm/arm-hisiv300-linux/bin/arm-hisiv300-linux-uclibcgnueabi-g++
cmake -DCMAKE_BUILD_TYPE=Debug -D_CONFIG_HI3516=1 ..
make
这样就不需要在每个工程中重新指定了,只在./c.sh中指定一次即可

.下一步,把c.sh不需要放在build目录下面,这样更加方便
//已解决,见D:\bear\board\demo\stud\c.sh
----------------------------------------------------------------

.采用gtest来做测试
 gtest支持linux和windows,比ctest和vs自带test更加通用

muduo中使用cmake自带的ctest
在muduo/build.sh中启用
CTEST_OUTPUT_ON_FAILURE=TRUE make test
运行build.sh即可
主要是make test会运行所有测试app,但ctest没有像vs,gtest那样提供一些宏，而是完全由开发者自行处理,和普通的app一样
所以还是要用cmake+gtest来做

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.05.28/////////////////////////////////////////////////////////////////////////////////////////////
vs2017安装好了,
https://social.msdn.microsoft.com/Forums/en-US/4ecc1495-de4d-432f-9886-94d28ced6dc9/vs-community-2017-installation-problems?forum=vssetup
用MicrosoftProgram_Install_and_Uninstall.meta.diagcab来uninstall x86 minimum runtime,然后各种折腾，
现在除windows sdk 10.xx之外，其他都已安装好，并且能正常使用
vs2017 enterprise的Test功能比vs2015更完善

Solution Explorer>project>Add Reference>
用Reference的好处是自动链接正确的lib,不需要手工用#pragma comment(lib,"")来区分x86/x64,debug/release等版本

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.05.26/////////////////////////////////////////////////////////////////////////////////////////////
.今天花2小时安装vs2017,都没能成功
 卡在visual c++ 2017 x86 minimum runtime 14.14.26405上面，报找不到这个安装包，感觉是microsoft安装有bug

用TotalCommand批量修改文件夹下的所有文件名大小写
选中文件后按Ctrl+M,先全部改为大写,关闭对话框后才生效，然后再全部改为小写

.现在corelooper中的Close,Destroy,OnClose,OnDestroy有点混乱,有时导致无限循环,stack overflow
需要约定好调用规则
Create()触发BM_CREATE
Destroy()触发BM_DESTROY

AddChild(make_shared<XX>())内部调用child.Create()
相当于make_shared<XX>().Create();

框架自动清除obj时会主动发送BM_DESTROY
app自行清理obj时，需要自行调用obj.Destroy(),否则不会触发其OnDestroy

BM_CLOSE
由app自行调用Close()才会触发BM_CLOSE,从而调用OnClose

Create对应Destroy
Destroy和Close没有任何关系，不会内置互相调用
Close应该和有Open概念的操作对应
SignalClosed

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.05.25/////////////////////////////////////////////////////////////////////////////////////////////
.现在BaseLooper中的Close,Destroy,OnClose,OnDestroy有点混乱,有时导致无限循环,stack overflow
//已做处理

.自动化测试

////////////////////////////////////////////////////////////////////////////////////////////
2018.05.22/////////////////////////////////////////////////////////////////////////////////
bug fixed:
.StringTool::Replace

changes:
.修改了BaseHandler::Destroy(),有待测试

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.05.11/////////////////////////////////////////////////////////////////////////////////////////////
.发现TCP&UDP测试工具有一个bug
 tcp连接成功之后很快发一串数据，用wireshark可以看到OS已收到数据并ack,但测试工具界面上没有显示数据
 后续再发数据时能收到，但最开始的数据是完全丢失了
.经测试，发现如果向史工板子发了回复，就会收到不新的传感器数据了

E:\os\imgui
开源opengl和directx做的UI界面，很好

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.05.10/////////////////////////////////////////////////////////////////////////////////////////////
发现C盘空间突然变的很小，用spacesniffer发现windows自动打开了SearchIndex占用了11GB
https://www.fosshub.com/SpaceSniffer.html
在服务中要禁用Windows Search
全盘搜索可用Everything

https://www.fosshub.com/
上面有很多好用的软件下载，没有病毒，没有广告


开源音频软件，非常好用
https://www.audacityteam.org/

有时升级android studio或NDK之后编译会报错，解决办法:
删除
.gradle
.idea
app/.externalNativeBuild
app/build

////////////////////////////////////////////////////////////////////////////////////////////
2018.05.02/////////////////////////////////////////////////////////////////////////////////
.ftp数据收发具有通用性，需要做一个通用的框架来表达,支持级联


////////////////////////////////////////////////////////////////////////////////////////////
2018.04.24/////////////////////////////////////////////////////////////////////////////////
changes:
.增加了LOOPER_SAFE,加上函数接口前面表示是looper安全的，可以跨looper调用
#define LOOPER_SAFE	//表示接口是跨looper安全的
//约定:
//采用LOOPER_SAFE修饰的接口可以安全的跨looper调用
//没有采用LOOPER_SAFE修饰的接口，不保证跨looper安全调用，应该只在handler所在looper里调用


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.23/////////////////////////////////////////////////////////////////////////////////////////////
人脸识别
https://github.com/davisking/dlib


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.21/////////////////////////////////////////////////////////////////////////////////////////////
bug fixed:
.std::sort的compare函数返回值是bool,以前一直以为是int
.FileFinder采用string+StringTool替换CStringEx了
.FtpServer采用string+StringTool替换CStringEx了

.今天发现CStringEx在批量导出mcu大量数据时很慢，而MFC CString很快
void McuExportDataAdvancedPage::Dump()
发现STL string和MFC CString都很快
是时候去掉CStringEx了,可用stl string来做
去掉CStringEx,改用string
采用StringTool增加几个辅助函数，实现string AppendFormat等常用接口
//已删除CStringEx,增加了StringTool类

.AsyncTaskLooper::OnMessage中
	auto info = mTasks.front();
	mTasks.pop_back();应该是mTasks.pop_front();
//已改正

////////////////////////////////////////////////////////////////////////////////////////////
2018.04.20/////////////////////////////////////////////////////////////////////////////////
文件名全部采用小写
#include中的全部要改正

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.19/////////////////////////////////////////////////////////////////////////////////////////////
.vs2017和linux build.sh都可编译了
.linux demo timer采用build.sh编译ok
 //运行也ok


build.sh可以自动编译libcorelooper.a和demo中的多个工程

.按muduo中的要求很严格的编译选项,把所有警告都当作error
.增加自动化测试


查看linux时区
date +"%Z %z"

ubuntu上面
bear@ubuntu:~/work/t20$ date +"%Z %z"
CST +0800

.vs2017可以调试，单步执行python!

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.18/////////////////////////////////////////////////////////////////////////////////////////////
force utf8 vsix在vs2017下不能工作，感觉有必要重新写一个
https://docs.microsoft.com/en-us/visualstudio/extensibility/starting-to-develop-visual-studio-extensions
可下载为pdf

https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.text.itextdocument?view=visualstudiosdk-2017
ITextDocument Interface
Encoding:Gets or sets the encoding of the document when saved to disk.


https://www.codeproject.com/Articles/1169776/Visual-Studio-Extensibility-Day-Creating-your-firs?msg=5505104
https://www.codeproject.com/Articles/1170705/Visual-Studio-Extensibility-Day-Deploying-Visual-S
https://www.codeproject.com/Articles/1175304/Visual-Studio-Extensibility-Day-Visual-Studio-exte


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.17/////////////////////////////////////////////////////////////////////////////////////////////
打算重新整理出一个BaseLooper,用于上传到github

源代码文件名决定还是全部采用小写,原因是visual studio和svn对文件名大小写支持不好，经常搞的混乱
//发现是svn的问题，和vs没太大关系

用total command可批量转小写
total command>File>Multi Rename Tool...


changes:
.vs x86,x64 compile ok


https://jocent.me/2017/06/25/dns-protocol-implementation.html
自己动手用c++实现DNS解析
////////////////////////////////////////////////////////////////////////////////////////////
2018.04.16/////////////////////////////////////////////////////////////////////////////////
BaseLooper改名为CoreLooper

.vs2015 Device现在调试时如果修改了代码，按shift+F5停止调试时容易挂住，任务管理器中都杀不了
只能重启电脑
//禁用了edit and continue,看问题是否重现

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.13/////////////////////////////////////////////////////////////////////////////////////////////
今天编译了陈硕的muduo,编译很顺利，直接运行./build.sh就好
一个warning都没遇到
Z:\os\muduo\build.sh
muduo采用了cmake并且运用的很好,很多地方值得学习
.生成的文件完全out of tree,是指定在../build目录中的，临时文件完全与代码文件分离
.同一CMakeLists.txt可生成多个target
.自动定位依赖库，比如boost等

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.04.06/////////////////////////////////////////////////////////////////////////////////////////////
pdf download
http://www.xuexi111.com

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.03.28/////////////////////////////////////////////////////////////////////////////////////////////
1.只查看该进程：ps -ef | grep 11345
2.查看该进程打开的文件：lsof -p 11345
3.查看内存分配：lcat /proc/11345/maps
4.查看堆栈：pstack 11345
5.查看发出的系统调用:strace -p 11345
6.查看调用库函数:ltrace -p 11345

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.03.25/////////////////////////////////////////////////////////////////////////////////////////////
路由表详解
http://blog.51cto.com/tonyguo/176104

今天在miphone中安装了一个"wifi分析仪"
能以图表查看当前能搜索到的wifi router信号强度，信道等信息

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.03.19/////////////////////////////////////////////////////////////////////////////////////////////
Adobe Reader>Edit>Preferences>Documents>Remember current state of Tool Pane

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.03.16/////////////////////////////////////////////////////////////////////////////////////////////
.根据epc定位源码成功
do_page_fault() #2: sending SIGSEGV to MainLooper for invalid read access from 00000000 (epc == 007c3580, ra == 0072b5cc)
bear@ubuntu:~/work/nfs$ /opt/jco/mips-gcc472-glibc216-64bit/bin/mips-linux-gnu-addr2line -e ~/work/nfs/ds 007c3580
/mnt/bear/board/device/src/system/platform/CameraPlatformHandler.cpp:399
line 399是
mProtocol->AddCommand("LatestUploadPictureFileInfo");
看来是运行到此行时mProtocol为nullptr引起的

https://www.zhihu.com/question/40646841
最让你震惊的一宗杀人案件是什么？

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.28/////////////////////////////////////////////////////////////////////////////////////////////
linux后台运行程序（secureCRT断掉或关闭后继续运行程序）
通过securecCRT远程运行的app,如果关闭secureCRT，程序一样无法执行。当用户注销或者网络中断时，终端后收到SIGHUP信号，从而关闭其所有子进程。

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.27/////////////////////////////////////////////////////////////////////////////////////////////
ubuntu配置tftp server
https://www.linuxidc.com/Linux/2013-07/87366.htm

ubuntu 检查打开了哪些udp端口
netstat -uanp

SecureCRT 设置超时自动断开连接时长
Options->Session Options->Terminal->Anti-idle->勾选Send protocol NO-OP

udp rdt
https://github.com/skywind3000/kcp


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.26/////////////////////////////////////////////////////////////////////////////////////////////
iptables -I INPUT -s 103.200.56.0/24 -j DROP

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.25/////////////////////////////////////////////////////////////////////////////////////////////
Linux查找含有某字符串的所有文件
find -type f -name '*.h'|xargs grep 'SO_REUSEPORT'

vs Tools>Options>Text Editor>c/c++>Formatting>Indentation>Indent namespace contents

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.22/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.BaseUdpServer_Linux增加了map<string, weak_ptr<BaseUdpClient_Linux>> mClients;
 当accept recvfrom收到数据时，查询ip:port对应的client,找到则投递包，否则创建client
.BaseUdpClient_Linux增加了list<shared_ptr<ByteBuffer>> mPendingData;
 //这样能保证同一client socket发送的包统一由相应的BaseUdpClient_Linux来响应

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.21/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.udp BaseUdpClient_Linux
//test ok,注意:client在发送第一个包后要等server执行bind,connect,
 此后BaseUdpClient_Linux才能响应client发送的包
 如果client一运行就用同一udp socket发送几个包，
 则server会采用BaseUdpServer_Linux::OnAccept()来响应
 需要等server bind,connect之后,linux kernel才能把后续此socket的udp包转给BaseUdpClient_Linux

netstat -an -p udp | grep 8000

从UDP的”连接性”说起–告知你不为人知的UDP
http://blog.csdn.net/chenlycly/article/details/51582257
https://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.18/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.增加了BaseUdpServer_Windows,可以接收到udp数据了
 BaseUdpServer_Windows的生命周期管理
 UdpIoContext采用mBaseServer强引用BaseUdpServer_Windows,保证有io进行时BaseUdpServer_Windows一直有效
 调用BaseUdpServer_Windows::Stop()后,会触发BaseUdpServer_Windows::DispatchIoContext recv 0字节
 此时PostDispose(context->mBaseServer);即可
.UdpIoContext生命周期管理
 UdpIoContext自带mSelfRef,在IoContextType_Recv时如果结束则mSelfRef = nullptr;

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.15/////////////////////////////////////////////////////////////////////////////////////////////
生成能调试的live vs工程，很简单
创建一普通的MFC app工程，把live中的.cpp和.hh都加进来
c++ include path:
.;BasicUsageEnvironment/include;groupsock/include;liveMedia/include;UsageEnvironment/include;

c++ preprocessor:
_WINSOCK_DEPRECATED_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;

选中所有.cpp(MFC自动生成的.cpp除外),禁用pch
然后即可编译x86和x64都可以成功


九条命，音轨2为中文
从mkv转成mp4,并采用中文音轨
ffmpeg -i 9life.mkv -map 0:v -vcodec copy -map 0:a:1 -acodec copy 9life.mp4
//test ok


ffmpeg -i 9life.mp4 -vcodec copy -acodec aac 9life.adpcm.mp4


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.14/////////////////////////////////////////////////////////////////////////////////////////////
.增加了D:\os\udt.sdk.4.11\udt\udt.sln
 可在vs编译运行各项目,用来研究rudp
.udt增加了cmake
 cd /mnt/os/udt.sdk.4.11/bin/pclinux/debug/
 ./c.sh
生成的app在~/work/nfs下面

在vs中运行sendfile
在ubuntu中运行recvfile
cd ~/work/nfs/
 ./recvfile 192.168.1.3 9000 x.zip recv.zip 
可以测试用udt收发文件
wireshark支持解析udp报文
https://wiki.wireshark.org/UDT

udt rfc草案，已过时，可能是响应的人太少了，没有成为标准,但参考价值是有的
https://tools.ietf.org/html/draft-gg-udt-03

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.13/////////////////////////////////////////////////////////////////////////////////////////////
春节任务规划
.vs test,cmake test自动化测试
.BaseLooper增加udp
.pclinux gdb调试，定位各种可能出现segv,sigbus

--------------------------------------------------------
查看linux库文件32位还是64位
objdump -a  *.a
objdump -a  *.so

file libxx.a
readelf -h libxx.a

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.10/////////////////////////////////////////////////////////////////////////////////////////////
.ps导出32bit.bmp
 File>Save as...>save as .bmp>注意勾选alpha channel>save>32bit>Advanced Modes>勾选A8 R8 G8 B8>OK

.发现gdb调试能力太差
 DV("delay %d ms to try mount", mDelayTryMountTick);
 写成
 DV("delay %s ms to try mount", mDelayTryMountTick);
 后在t20上面运行报do_page_fault() #2: sending SIGSEGV to MainLooper for invalid read access from 000003e8 (epc == 7761faa0, ra == 7761792c)
 并且串口打印的其他消息和这个do_page_fault并不同步,gdb bt call stack定位不了，这样调试定位很困难,而在vs中能很快定位代码行
///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.04/////////////////////////////////////////////////////////////////////////////////////////////
可在vs下编译运行libuv app,工程在D:\os\libuv\uv\uv.sln
libsourcey基于libuv,也可研究一下
.参考libuv,把udp加到BaseLooper

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.03/////////////////////////////////////////////////////////////////////////////////////////////
Pencil 是一款开源的手绘风格原型图绘制工具，可以用来绘制各种架构图和流程图。
http://pencil.evolus.vn/Downloads.html

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.02/////////////////////////////////////////////////////////////////////////////////////////////
bug fixed:
.发现t20 现在Segmentation fault和AddChild(make_shared<GpsHandler_NMEA>());有关
 不创建GpsHandler_NMEA就能正常出视频，否则每次必现crash
	do_page_fault() #2: sending SIGSEGV to linux_stb for invalid read access from
	00000000 (epc == 00000000, ra == 00000000)
	因为缺少正确的$ra，linux gdb也无法显示调用栈。
//已解决，原因如下
 GpsHandler_NMEA有时读到0x00字符，在GpsNmeaParser::Input中
	const char *p = (const char*)mInbox.GetDataPointer();
	if (strstr(p, "$GPGGA") && strstr(p, "$GPVTG"))
	没有考虑p为nullptr的情况，strstr(nullptr,"xxx")会crash
 感觉c库为追求效率过于死板,这么容易出现的bug居然连call stack都看不到，导致排查困难

changes:
.重构MainLooper_Device,Board
 给每种方案创建自己的main looper,board，便于管理
 技巧:每个功能模块都要能启用或禁用,不需要重新编译
 比如启用
 AddChild(make_shared<GpsHandler_NMEA>());
 而下面是禁用
 //AddChild(make_shared<GpsHandler_NMEA>());
 这样能隔离各个模块，快速排查bug

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.02.01/////////////////////////////////////////////////////////////////////////////////////////////
.umount nfs失败的问题
//已解决
	umount: can't umount /tmp/nfs: Device or resource busy
	用fuser -m  /tmp/nfs可看到是谁占用了nfs目录,是非常有用的命令
	fuser -k  /tmp/nfs 可杀掉所有占用nfs的app

.tftpd开源，能用vs编译运行
E:\os\tftpd\sourceCode\tftpd64\tftpd32.sln

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.30/////////////////////////////////////////////////////////////////////////////////////////////
.在做BaseLooper框架demo时，可考虑做一个FtpServer,这样用户能看到各种用法

用vs编译curl ok
https://curl.haxx.se/download/
E:\os\curl-7.58.0\projects\Windows\VC15\curl-all.sln
注意要用vs2017打开


Automated WebRTC build scripts for Linux, Windows, Mac, Android and iOS. 
https://github.com/sourcey/webrtc-builds

预编译好的webrtc库
https://sourcey.com/precompiled-webrtc-libraries/


///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.29/////////////////////////////////////////////////////////////////////////////////////////////
gdb调试多进程和多线程命令
http://blog.csdn.net/pbymw8iwm/article/details/7876797

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.28/////////////////////////////////////////////////////////////////////////////////////////////
查看带宽用量iftop -B -i eth1，能列出最大的流量到哪些ip去了

nethogs eth1 查看占用带宽最大的几个进程
https://www.bennythink.com/nethogs-bug-v0-8-0.html
nethogs – creating socket failed are you root?

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.18/////////////////////////////////////////////////////////////////////////////////////////////
https://github.com/lucpp/DesktopLiveStreaming
已下载到E:\os\iocp\DesktopLiveStreaming,可用vs编译运行，
支持http flv和HLS,能在网页中看到效果,也能用vlc看
很有参考价值,可用在我们camera html5上面

////////////////////////////////////////////////////////////////////////////////////////////
2018.01.10//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.HttpFormField::mDataReady忘记初始化为false，已加上

////////////////////////////////////////////////////////////////////////////////////////////
2018.01.09//////////////////////////////////////////////////////////////////////////////////
.已测试MFC如下场景
	case eTimerTest:
	{
		DV("%s", __func__);
		SendMessage(WM_POP_DIALOG);
		return;
	}
LRESULT CTestTimerDlg::OnPopDialog(WPARAM wp, LPARAM lp)
{
	CAboutDlg dlg;
	dlg.DoModal();
	return 0;
}
发现MFC中即使OnTimer没有返回，仍然会再次触发此timer，这样容易引起重入问题
我们BaseLooper为简化这一点，在执行onTimer时会屏蔽此looper再次进入onTimer,避免重入问题
这个影响应该不大，设计理念本来就是onTimer中不能阻塞

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.06/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.ShellTool::GetTickCount()全面升级到GetTickCount64()

.ds ingenic compile ok

google开源的gperftools可以测试c++代码各api占用的cpu时间，可用来做性能优化
https://github.com/gperftools/gperftools

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.04/////////////////////////////////////////////////////////////////////////////////////////////
.增加了BaseLooper::Object,为BaseLooper::CurrentLooper()->FindObject的简写
.增加了_Object宏
 

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.02/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.TimerManager::GetMinIdleTime在hi3516下test ok

bug fixed:
.TestLooper中setTimerEx(-1)后TimerManager delay为1048576ms,导致TestLooper无法退出
//已解决，是BaseHandler::RemoveAllTimer()中把-1 timerId删除，导致BaseLooper一直阻塞
//在BaseHandler::RemoveAllTimer()中不要删除-1 timer即可

///////////////////////////////////////////////////////////////////////////////////////////////////////
2018.01.01/////////////////////////////////////////////////////////////////////////////////////////////
按http://www.stunprotocol.org/源码中的stunserver/README在ubuntu下编译成功
安装boost和opengssl:
sudo apt-get install libboost-dev # For Boost
sudo apt-get install libssl-dev # For OpenSSL
make即可

测试
先运行服务器
stunserver/stunserver
再运行客户端
bear@ubuntu:/mnt/os/p2p/stunserver$ ./stunclient localhost
Binding test: success
Local address: 127.0.0.1:33126
Mapped address: 127.0.0.1:33126
bear@ubuntu:/mnt/os/p2p/stunserver$ 

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.29/////////////////////////////////////////////////////////////////////////////////////////////
case 5:在hi3516上面跑50个TestLooper,每个TestLooper中SetTimer(5ms)
	在timer中打印消息cpu占用1.2~1.8%
	在timer中不打印消息cpu占用0.3~0.7%

b /mnt/bear/share/bearcore/arch/linux/BaseLooper_Linux.cpp:188

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.28/////////////////////////////////////////////////////////////////////////////////////////////
增加了_CONFIG_DEBUG_LOOPER,来调查looper和timer阻塞的情况
StorageManager.timer#end  ,id=100,tick=1511
DeviceFindHandler.timer#end  ,id=0,tick=0333
ButtonHandler.timer#end  ,id=0,tick=0334
OnvifDiscover.timer#end  ,id=0,tick=0333
WifiManager.timer#end  ,id=100,tick=0334
OsdManager_MTK6572.timer#end  ,id=0,tick=0334
Gpio.timer#end  ,id=0,tick=0334
BaseRtspServerHandler.timer#end  ,id=3001,tick=0334

决定调查一下looper在hi3516上面占用cpu过高的问题
case 1.只跑空的TestLooper,没有加timer,cpu始终为0
case 2.TestLooper加一个10*1000的timer,cpu:0.1~0.4%,出现过0.7%
case 3.TestLooper::TestSelect()测试5ms超时,cpu和case 2占用的相近
编译pc linux版，发现TestLooper::TestSelect()在ubuntu下占用的cpu和case2 hi3516上相近
case 4:TestLooper::TestSelect()在hi3516和ubuntu下测试100ms超时,cpu基本为0.0%,很少情况下为0.3%

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.26/////////////////////////////////////////////////////////////////////////////////////////////
srs_rtmp可以推直播流

今天在家里翻出一个超小的usb wifi网卡
fritz wlan usb stick AC 860
拿到公司居然可以使用

////////////////////////////////////////////////////////////////////////////////////////////
2017.12.25//////////////////////////////////////////////////////////////////////////////////
.AsyncTask有待改进的地方
 要支持cancel
 最好能支持looper池技术,对task可指定等待超时时间,超过此时间后创建新的looper来执行此task,
 避免单个task阻塞过长时间引起后续task全部延时过长

////////////////////////////////////////////////////////////////////////////////////////////
2017.12.24//////////////////////////////////////////////////////////////////////////////////
.TimerManager::DoTimeOutCallBack()中可能存在如下问题
 在node->mHandler->onTimer中删除某个timer时，
 如果此timer恰好已在mReadyNodes中，则killTimer之后还会触发一次onTimer
//已测试确认不会出现此问题
//如果删除的timerId恰好已加入mReadyNodes也能保证killTimer之后不会触发此timer
//RemoveTimer会从mReadyNodes中移除

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.24/////////////////////////////////////////////////////////////////////////////////////////////
stun open source
http://www.stunprotocol.org/

libnice
https://github.com/libnice/libnice.git

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.22/////////////////////////////////////////////////////////////////////////////////////////////
ubuntu 16.04下同步时间
sudo ntpdate ntp.ubuntu.com

https://www.cnblogs.com/kobe8/p/3825461.html
linux下使用 du查看某个文件或目录占用磁盘空间的大小
du -ah --max-depth=1
在hi3516上面要用du -ah -d 1
/mnt/app # du -ah -d 1
0       ./sd
256.0K  ./boa
0       ./nfs
8.5K    ./www
4.4M    ./bear
18.0K   ./chat
958.5K  ./libs
179.0K  ./pppd
2.0M    ./wifi
3.1M    ./komod
512     ./peegine.log
270.0K  ./iptables
512     ./gpio_cfg.ini
512     ./IPRate.conf
0       ./.strm0_0_buf
0       ./.strm0_1_buf
22.0K   ./ntpclient
0       ./.strm0_2_buf
23.5K   ./factory_settings
10.0K   ./CKRate
512     ./start_app.sh
1.0K    ./start_network
512     ./product_info.ini
40.0K   ./dhcpcd
7.0K    ./cgiServer
19.0K   ./udhcpc
18.0K   ./udhcpd
18.0K   ./lan_search
11.3M   .

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.15/////////////////////////////////////////////////////////////////////////////////////////////
.发现ds在hi3516上占用cpu太高，和getMessage中没处理好next timer ms有关
 有待彻底研究time wheel
 //已解决
 
 Reinventing the timer wheel https://lwn.net/Articles/646950/
 这篇文章说了time wheel的一些缺点并提出了改进方法，其代码已合并到linux kernel 4.8

调查ds占用cpu比较高的原因
1.pstree:查看linux进程的线程
2.ps -T,-T表示显示线程
3.运行top,然后按H,H命令可以显示各个线程的情况

~ # pstree
init-+-CamMainLooper-+-{ADEC_SendAoPro}
     |               |-{AsyncTaskLoope}
     |               |-{BaseLooper_Lin}
     |               |-2*[{CamMainLooper}]
     |               |-3*[{CloudP2PListen}]
     |               |-{DnsLooper}
     |               |-{Homeworker}
     |               |-{RecordLooper}
     |               `-{aenc_get}
     |-sh
     |-telnetd---sh---pstree
     `-udevd---2*[udevd]
~ # 

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.14/////////////////////////////////////////////////////////////////////////////////////////////
今天王金成来公司谈ipcam合作事项
王是广西玉林人,做单片机软件开发
.音频直接用咪头,不需要外部音频输入
.camera和硬盘录像机放在同一局域网下面,所以nvr可通过onvif来录像


-------------------------------------
.3516主板和小板的连接线接触不好时，可导致wifi连接不上
 插好连线,重启即可恢复正常


.现在hi3516画面不对，要旋转90度才行
 试图用软件办法来解决，发现不行，陈工发的
 Z:\jjy\Hi3516A_SDK_V1.0.7.0\mpp\sample.imx322.可rotate90度.但高比宽大，不是我们要的效果
 只能在下版硬件来修改sensor芯片放置方向

--------------------------------------------------
.h.265 camcoreDemo能出一小会视频，然后视频卡住，通道正常
 在VideoSource::InputFrame增加打印tick,发现h.265码流是一直都有的，并且时间是均匀的，说明板端性能是足够的
//发现是camcoreDemo上解码忙不过来,解一帧需要40ms到60ms,但VLC能同时解4个1080p h.265都没有问题
 有待进一步研究
 可能是要升级ffmpeg,优化编译选项?

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.13/////////////////////////////////////////////////////////////////////////////////////////////
昨天改了一下BaseHandler头文件,后面编译出的ds在hi3516上面运行每次都自动重启
恢复到svn上的旧版本，重新编译，运行正常
比较此旧版本和最新版本，发现没有明显差异
重新采用最新版本完全编译，运行正常
看来是有时修改某个头文件之后，编译系统不正常，导致生成的app有bug
vs也遇到过类似的问题，重新全编译后问题消失

////////////////////////////////////////////////////////////////////////////////////////////
2017.12.12//////////////////////////////////////////////////////////////////////////////////
.BaseHandler可以在PostDispose中主动发送BM_DESTROY
//已测试，不行，会导致无限循环

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.09/////////////////////////////////////////////////////////////////////////////////////////////
http://blog.csdn.net/u011249920/article/details/51374816
Android Audio回声消除学习笔记
AcousticEchoCanceler
回声消除AcousticEchoCanceler 继承自AudioEffect
声学回声消除器（AEC）AcousticEchoCanceler类消除了从远程捕捉到音频信号上的信号的作用
自动增益控制（AGC）AutomaticGainControl类自动恢复正常捕获的信号输出
噪声抑制器（NC）NoiseSuppressor类可以消除被捕获信号的背景噪音
注意:并不能保证所有的设备都能支持这些效果的，所以你应该首先调用在对应音频效果类上的isAvailable()的方法来检测它的可用性
https://developer.android.google.cn/reference/android/media/audiofx/AcousticEchoCanceler.html

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.12.08/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.UdpIocpDlg test ok,有待进一步研究

现在公司有好几个项目同时进行，有必要进行项目管理
用手机注册了腾讯的tapd
https://www.tapd.cn
也用手机号注册了worktile.com,但决定用tapd

单独写的UdpTest测试组播，在hi3516和ubuntu上每次都能收到win7和win10上面的onvif test tool搜索
/mnt/app/nfs # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.1     0.0.0.0         UG    0      0        0 ra0
192.168.1.0     *               255.255.255.0   U     0      0        0 ra0

////////////////////////////////////////////////////////////////////////////////////////////
2017.12.04//////////////////////////////////////////////////////////////////////////////////
todo:
.BaseHandler子类如果重载了OnDestroy(),而没有主动调用它
 当BaseHandler析构时调用OnDestroy(),此时没法调用到子类的OnDestroy()
 MFC中的CWnd::~CWnd()也有同样的问题,它采用的是如下警告
	CWnd::~CWnd()
	{
		if (m_hWnd != NULL &&
			this != (CWnd*)&wndTop && this != (CWnd*)&wndBottom &&
			this != (CWnd*)&wndTopMost && this != (CWnd*)&wndNoTopMost)
		{
			TRACE(traceAppMsg, 0, _T("Warning: calling DestroyWindow in CWnd::~CWnd; ")
			   _T("OnDestroy or PostNcDestroy in derived class will not be called.\n"));
			DestroyWindow();
		}
		...
	}
//可能的解决办法包括:
.提供一个接口，主动调用OnDestroy();
.在子类析构时主动调用OnDestroy()

.BaseHandler在析构时，如果和父窗口不在同一线程，则没法调用RemoveChildWeakRef来清理parent对child的weak ref
 原因:如果child是looper,此时没法sendMessage

////////////////////////////////////////////////////////////////////////////////////////////
2017.11.30//////////////////////////////////////////////////////////////////////////////////
changes:
.StartWithinCurrentThread改名为StartRun()

////////////////////////////////////////////////////////////////////////////////////////////
2017.11.21//////////////////////////////////////////////////////////////////////////////////
.BaseHandler中PostDispose可用struct增加mSelfRef优化掉对struct的new/delete
 对BaseHandler的mSelfRef最好也能在真正响应PostDispose时清除
.BaseLooper中的ini可去掉，绝大部分的looper是不需要ini功能的
.BaseHandler中的IProcDataGetter和IProcDataSetter可以用一个子类BaseProcHandler来做
 这样可减轻BaseHandler负担
 当需要使用proc功能时从BaseProcHandler继承
.采用timer机制来完成BaseHandler::postDelayed
////////////////////////////////////////////////////////////////////////////////////////////
2017.11.16//////////////////////////////////////////////////////////////////////////////////
昨晚测试，重现了mOutPending_VideoRtps缓存太多帧的bug
###Warning[2017.07.07 00:54:59.040][mOutPending_VideoRtps.size()=3607]                              (/mnt/bear/share/bearcore/core/net/rtsp/BaseRtspServerHandler.cpp:1138)
###Warning[2017.07.07 00:55:48.520][rtsp timeout,disconnect data channel,this=0x190c530]            (/mnt/bear/share/bearcore/core/net/rtsp/BaseRtspHandler.cpp:70)
DeviceMainLoope invoked oom-killer: gfp_mask=0x201da, order=0, oom_adj=0, oom_score_adj=0
之前以为已解决此问题
//已加上判断，当mOutPending_VideoRtps超过1024时主动断开

////////////////////////////////////////////////////////////////////////////////////////////
2017.11.15//////////////////////////////////////////////////////////////////////////////////
changes:
.发现AsyncTaskLooper一个bug,嵌套执行多个task,而不是串行执行
//原因已找到，是在AsyncTaskLooper sendMessage到其他looper导致的
 已采用mBusying+缓存来解决
.linux cmake能正确编译debug和release版了
 SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -D NDEBUG")

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.11.14/////////////////////////////////////////////////////////////////////////////////////////////
timer id使用有点麻烦，基类和子类的timer id容易冲突,最好能改成自动分配
class BaseTimer
{
public:
	BaseTimer(shared_ptr<BaseHandler> handler);
	virtual ~BaseTimer()
};


auto timer=BaseTimer(shared_ptr<BaseHandler> handler);

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.11.09/////////////////////////////////////////////////////////////////////////////////////////////
在Android Studio下测试了Debug和Release编译
AS>Build>Select Build variant
选Debug时,app\.externalNativeBuild\cmake\debug\armeabi\cmake_build_command.txt中-DCMAKE_BUILD_TYPE=Debug
选Release时,app\.externalNativeBuild\cmake\release\armeabi\cmake_build_command.txt中-DCMAKE_BUILD_TYPE=Release
在代码中自动判断Debug/Release:cmake release时会定义NDEBUG
#ifndef _MSC_VER
	#ifndef NDEBUG
	#define _DEBUG
	#else
	#undef _DEBUG
	#endif
#endif
即可统一使用_DEBUG来判断
即使AS build variant选的是Debug,当build signed apk时仍然会采用Release,这是正确的行为

而在linux cmake中-DCMAKE_BUILD_TYPE=Release时没有自动定义NDEBUG
解决办法:
手工加上
SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -D NDEBUG")

cmake Debug版会使用参数-g；Release版使用-O3 –D NDEBUG
所以当定义了NDEBUG时为release,否则为debug版

////////////////////////////////////////////////////////////////////////////////////////////
2017.11.03//////////////////////////////////////////////////////////////////////////////////
changes:
.BaseTcpHandler在windows下要增加对dns域名的支持，目前是只支持ip
//已加,test ok

.BaseTcpClient_Linux增加域名支持
//已加，有待测试

////////////////////////////////////////////////////////////////////////////////////////////
2017.11.02//////////////////////////////////////////////////////////////////////////////////
changes:
.增加了AsyncTask机制，和android下的一样
典型用法
创建一个class WifiScanner:public AsyncTask
调用:
{
	//.在looper环境下调用
	//.必须在设定了MainLooper的情况下才能调用
	auto obj = make_shared<WifiScanner>();
	obj->Execute();
}

//在AsyncTask所在looper被调用
virtual void OnPreExecute() = 0;
virtual void OnPostExecute() = 0;

//在AsyncTaskLooper中被调用
virtual void Run() = 0;

pre和post execute可在Execute时可enable/disable

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.10.26/////////////////////////////////////////////////////////////////////////////////////////////
Android Studio升级到 3.0
卡在build gradle info的解决办法
用迅雷下载http://services.gradle.org/distributions/中的gradle-4.1-all.zip
放到C:\Users\bear\.gradle\wrapper\dists\gradle-4.1-all\bzyivzo6n839fup2jbap0tjew\gradle-4.1-all.zip

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.10.19/////////////////////////////////////////////////////////////////////////////////////////////
http://www.vivato.com/
vivato的wifi可以支持6.5公里远

Vivato无线WiFi产品在校园中的应用
http://www.docin.com/p-187956479.html

////////////////////////////////////////////////////////////////////////////////////////////
2017.10.18//////////////////////////////////////////////////////////////////////////////////
postMessage时避免直接调用new和delete的办法
struct tagXXX
{
	shared_ptr<tagXXX> mRef;
}
auto info=make_shared<tagXXX>();
info->mRef=info;

在响应postMessage时info->mRef=nullptr;

////////////////////////////////////////////////////////////////////////////////////////////
2017.09.14//////////////////////////////////////////////////////////////////////////////////
.linux下设置thread name
 #include <sys/prctl.h>
 prctl(PR_SET_NAME, (unsigned long)szThreadName, 0, 0, 0);

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.09.08/////////////////////////////////////////////////////////////////////////////////////////////
开源的json库rapidjson,tencent也推荐这个
E:\os\rapidjson

////////////////////////////////////////////////////////////////////////////////////////////
2017.08.28//////////////////////////////////////////////////////////////////////////////////
.BaseDataEndPoint需要增加IsConnect()接口
 目前没有接口来判断是否已连接

.BaseHandler setTimer设计有缺陷，timerId容易冲突
 有可能基类已经使用某个timerId,但子类用同样的timerId来做其他事务
 最好是去掉timerId的概念，改为如下调用方法
 mTimerId1=setTimer(interval);
 mTimerId2=setTimer(interval);
 然后在onTimer(timerId)中用mTimerId1,mTimerId2来判断

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.08.17/////////////////////////////////////////////////////////////////////////////////////////////
用adboe reader看2440原理图时，明明有nLED_1,但它就是搜索不到
网友建议用极速pdf,经试用，果然好用

.听网友说openOCD可以单步调试arm裸板程序
///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.08.10/////////////////////////////////////////////////////////////////////////////////////////////
发现了vs的一个很方便的功能
project reference
TestUsb在添加libusb为reference之后，能自动引用libusb的.lib和.dll,不需要再显示指定.dll和.lib的目录

libusb要在windows上使用的话，需要安装usbk驱动，下载地址
https://sourceforge.net/projects/libusb-win32/files/libusbK-release/
已测试，安装上后libusb_open就能打开设备了


///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.08.05/////////////////////////////////////////////////////////////////////////////////////////////
CMakeLists.txt中相对目录
${PROJECT_SOURCE_DIR}/src/main/cpp/os/android.common/libavcodec.a
${PROJECT_SOURCE_DIR}/src/main/cpp/os/android.common/libavutil.a

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.08.02/////////////////////////////////////////////////////////////////////////////////////////////
http://www.usr.cn/
有人科技，名字太有才了
有人的网站做的很大气,可参考

有人的传感器网页做的比较好
http://cloud.usr.cn/demo/#/app/custom


////////////////////////////////////////////////////////////////////////////////////////////
2017.08.01//////////////////////////////////////////////////////////////////////////////////
.BaseLooper的StartWithinCurrentThread应该改为Run()
 Start()表示开启新的线程并运行
 Run()表示在当前线程运行
 这样比StartWithinCurrentThread简洁一些

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.07.20/////////////////////////////////////////////////////////////////////////////////////////////
网络变压器
trc41604nl

http://www.cnblogs.com/jason-lu/articles/3195473.html
①RJ-45接口
②Transformer(隔离变压器)
③PHY芯片
④MAC芯片

pci总线接mac总线,mac接phy,phy接网线(当然也不是直接接上的,还有一个变压装置).
MAC通过MII/RMII总线控制PHY

http://blog.csdn.net/yayong/article/details/5334565
以太网卡杂记之MAC和PHY

从HI3520 pdf可以看到它内置了MAC,所以需要外接PHY
而MT7620应该是内置了MAC+PHY,所以mt7620板子上面外接的是Transformer网络变压器trc41604nl
像S3C2440,即没有MAC,也没有PHY,所以从降低硬件成本的角度出发，要找集成了MAC+PHY的eth芯片,比如DM9000

2440+dm9000的应用
http://blog.csdn.net/ypoflyer/article/details/6209922

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.07.14/////////////////////////////////////////////////////////////////////////////////////////////

在ubuntu16上编译u-boot-1.1.6成功
从uboot官网下载u-boot-1.1.6,tar jxf或tar zxf解压
参考http://blog.chinaunix.net/uid-26226893-id-2480422.html
make smdk2410_config

在Makefile中修改
ifeq ($(ARCH),arm)
#CROSS_COMPILE = arm-linux-
CROSS_COMPILE = arm-hisiv300-linux-
endif


问题cc1: warning: target CPU does not support interworking
解决办法
#vi "cpu/arm920t/config.mk"
把 PLATFORM_CPPFLAGS += -march=armv4 改成 PLATFORM_CPPFLAGS += -march=armv4t
#PLATFORM_CPPFLAGS += -march=armv4
PLATFORM_CPPFLAGS += -march=armv4t

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.07.10/////////////////////////////////////////////////////////////////////////////////////////////
.提供android demo app,演示各种用法
.提供sdk详尽pdf文档

发现韦东山视频可以免费观看,比51cto上面的还全些,包括自己写bootloader和移植到最新的linux内核
https://item.taobao.com/item.htm?spm=a1z10.5-c.w4002-1253507044.10.4d318d70if8NlL&id=524159646562

已购买韦东山JZ2440v3开发板
JZ2440v3开发板资料光盘下载地址
http://pan.baidu.com/s/1dENZqdr

http://pan.baidu.com/s/1bpGmf8r
韦东山Linux_第1期视频_裸板u-boot内核文件系统驱动入门

烧写工具eop资料：https://pan.baidu.com/s/1c3ZjPW#list/path=%2F

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.07.09/////////////////////////////////////////////////////////////////////////////////////////////
http://edu.51cto.com//center/course/lesson/index?id=25558
怎么看原理图

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.07.04/////////////////////////////////////////////////////////////////////////////////////////////
http://blog.csdn.net/harry_lyc/article/details/6624960
string和wstring相互转换方法，标准C++做成，可以在Linux、Windows下运行
主要api为mbstowcs和wcstombs

////////////////////////////////////////////////////////////////////////////////////////////
2017.07.03//////////////////////////////////////////////////////////////////////////////////
p2p rfc

ICE
https://tools.ietf.org/html/rfc5245

STUN
https://tools.ietf.org/html/rfc5389

TURN
https://tools.ietf.org/html/rfc5766

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.30/////////////////////////////////////////////////////////////////////////////////////////////
.采用timer机制来完成BaseHandler::postDelayed
.可考虑把Android中的postDelay,Runnable调用加入looper
.仿照android looper,handler,message,messageQueue来重构

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.29/////////////////////////////////////////////////////////////////////////////////////////////
 Gradle version 2.2 is required错误解决
 http://blog.csdn.net/rflyee/article/details/51067793
 在Build.Gradle中的buildscript里加入
System.properties['com.android.build.gradle.overrideVersionCheck'] = 'true'

同时修改classpath 'com.android.tools.build:gradle:2.3.3'
确保此gradle版本在C:\Users\bear\.gradle\wrapper\dists中已存在

////////////////////////////////////////////////////////////////////////////////////////////
2017.06.28//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.BaseLooperImpl::CreateExitEvent()改为线程安全

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.27/////////////////////////////////////////////////////////////////////////////////////////////
adb tcpip 2000
adb connect 192.168.1.114:2000

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.26/////////////////////////////////////////////////////////////////////////////////////////////
升级bearcore,采用c++ namespace分级，支持unicode,全部采用string
namespace Bear
{
	namespace Core
	{
		Looper
		Handler
		Message
	}

	namespace Net
	{
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.20/////////////////////////////////////////////////////////////////////////////////////////////
https://developer.android.google.cn/studio/intro/index.html
android studio用户手册，很有用，需要详细研究

.增加了HandlerInfo.xml接口
 可显示Handler总数,用于检测是否有handler泄漏
 参数dump=1时会打印所有handler树形列表
http://192.168.1.3:8000/HandlerInfo.xml?user=admin&password=admin&dump=0
现在HandlerCount为68左右
.增加了BaseHandler::SetRationalHandlerUpperLimit,可设置合理的handler上限，目前默认为200
 超过此上限时会打印报警消息

.BaseLooper的message增加shared_ptr,保证handler的有效性
//已加

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.19/////////////////////////////////////////////////////////////////////////////////////////////
bug fixed:
.发现bearcore对epoll用法有漏洞,只调用了epoll_ctl的EPOLL_CTL_ADD和EPOLL_CTL_MOD
 从来没调用过EPOLL_CTL_DEL
 在没对timer引用handler时,可能出现当关闭socket并销毁BaseHandler之后,epoll_wait收到先前socket的回调事件，导致crash
 正确做法是在close socket时调用EPOLL_CTL_DEL
//已加

bug fixed:
.BaseHandler::OnDestroy()中对looper也要清除mTimerMap

changes:
message增加shared_ptr<BaseHandler>,编译运行初步ok
.looper要能正常退出
.timer要正常
//test ok

.检查BaseHandler泄漏
 在退出app之前调用
#ifdef _CONFIG_TEST_BASE_HANDLER
		BaseHandler::DumpAll();
#endif
可用DT查看泄漏的BaseHandler对象
在BaseHandler::Dump中断点可看对象详情

.map(电脑上用html网页来做,vc++可以和jscript交互)
https://msdn.microsoft.com/en-us/library/hh772183(v=vs.85).aspx
Web Platform API Reference Internet Explorer Platform APIs  Console Debugging API

 http://blog.csdn.net/charlessimonyi/article/details/18447471
 http://blog.csdn.net/charlessimonyi/article/details/18450783
 http://blog.csdn.net/charlessimonyi/article/details/50984903
 
 https://www.codeproject.com/Articles/2352/JavaScript-call-from-C
 vc++调用jscript function成功，很方便,在D:\bear\client\demo\JSCalls
 jscript调用c++ api待测，肯定也能成功

.CloudP2PWakeup在windows/android下面mChildren.size()经常为3,是tcp client没及时析构
 已找到原因如下:
	BaseHandler timer增加了ref count,在BaseDataEndPoint::OnCreate()中调用了SetTimer(eTimer_CheckAlive, 60 * 1000);
	而在close/disconnect中没有清除此timer,导致tcp client一直存在
 现在又重新考虑了一下，BaseHandler timer没有必要增加shared_ptr<BaseHandler>,原因如下:
	只能在BaseHandler所在的looper内创建timer
	BaseHandler在销毁时会清除它的所有timer
	在BaseHandler销毁后不能再创建timer
	这3个条件能保证timer触发时BaseHandler是有效的,所以timer不需要对handler做ref count
 按理来说timer不需要ref,但实测发现不加ref时,mtk6572经常死在timer里面，原因待查,最好在ubuntu下测试handler,looper+timer的生命周期
.timer难题
 timer对handler做引用时比较麻烦，在销毁之前要删除所有timer,否则handler会一直存在
 不对handler做引用，mtk6572下经常crash,原因还没找到
 另外,父和子handler中的timerId现在是硬编码的，可能重复导致冲突,最好handler提供能自动生成唯一的timerId
//做了改进，没再重现

.message现已采用shared_ptr<BaseHandler>保护，不再需要PostDispose来保护
//经重新考虑，发现仍然需要PostDispose机制,原因如下:
	shared_ptr<BaseHandler>只能保证当前响应消息的handler有效，不能保证其他handler的有效性
	c++与java有个不同的地方,用shared_ptr时,c++中可以执行类似this=nullptr即主动销毁对象,而java中是由GC来销毁的
	场景:
	在HandlerA在响应某个消息时，调用了HandlerB的方法,如果此时HandlerB直接让
	HanlderB::func1()
	{
		...
		PostDispose(mSelfRef);
		...
		//其他代码
	}
	如果在PostDispose处直接删除HandlerB,则后面的代码访问HandlerB时会crash
	PostDispose延时清除HandlerB,则较好的解决此问题
	归纳起来就是:对象不要直接删除自己，由框架来清除对象

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.17/////////////////////////////////////////////////////////////////////////////////////////////
重要经验:
.在AndroidStudio中按Atl+F5调试运行，在jni crash时AS会自动定位出错代码行


-Zm256 %(AdditionalOptions)

.cs在mtk6572上每几分钟就crash一次
06-16 20:50:41.333 21264-21318/com.maygion.bearcore A/libc: Fatal signal 11 (SIGSEGV) at 0x00005310 (code=0), thread 21318 (aygion.bearcore)
06-16 20:50:41.336 21264-21419/com.maygion.bearcore V/AudioRecord: Overrun user: 6978, server: 7978, flags 0001
06-16 20:50:41.338 21536-21536/? I/DEBUG: check process 21264 name:aygion.bearcore
06-16 20:50:41.339 21536-21536/? I/DEBUG: [OnPurpose Redunant in preset_info] pid: 21264, tid: 21318, name: aygion.bearcore  >>> com.maygion.bearcore <<<
06-16 20:50:41.443 21536-21536/? I/DEBUG: pid: 21264, tid: 21318, name: aygion.bearcore  >>> com.maygion.bearcore <<<
06-16 20:50:41.591 21536-21536/? I/DEBUG:     #01  pc 0027f76d  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (BaseTcpClient_Linux::OnEvent(unsigned int)+344)
06-16 20:50:41.591 21536-21536/? I/DEBUG:          53c3bc0c  52c5e3c7  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count()+34)
06-16 20:50:41.591 21536-21536/? I/DEBUG:          53c3bc24  52d5700f  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (std::__shared_ptr<TimerManager, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr()+22)
06-16 20:50:41.592 21536-21536/? I/DEBUG:          53c3bc54  52d54ea5  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (BaseLooperImpl::ProcessTimer(unsigned int&)+348)
06-16 20:50:41.592 21536-21536/? I/DEBUG:          53c3bc64  52ca46a5  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (std::_List_base<tagLoopMessageInternal, std::allocator<tagLoopMessageInternal> >::_M_put_node(std::_List_node<tagLoopMessageInternal>*)+30)
06-16 20:50:41.592 21536-21536/? I/DEBUG:          53c3bc6c  52e02869  /data/app-lib/com.maygion.bearcore-2/libbearcore.so (CCriticalSectionEx::UnLock()+32)

arm-linux-androideabi-addr2line -e D:\bear\share\bearcore\as\app\build\intermediates\cmake\debug\obj\armeabi\libbearcore.so -a 52e02869
经AndroidStudio定位，发现是rtsp server下的BaseDataEndPoint已销毁后收到message,根源是message没引用BaseHandler指针
解决办法是message中增加shared_ptr<BaseHandler>
android中有类似用法:message.target=handler;
这样能保证message被处理时handler保持有效

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.12/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.测试apk加扰成功，可防止第三方轻易反编译得到.java源码
过程如下
在app build.gradle的release和debug中增加
minifyEnabled true
proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
proguard一般会影响jni回调java中约定好的api名称，比如onDeviceEvent时会报找不到
所以要对jni回调接口禁用proguard
修改proguard-rules.pro
主要是增加
-keep class com.netease.nis.bugrpt.** {*;}
-keep class com.jni.** {*;}
技巧，对debug也启用proguard是为了方便在AS中直接运行apk,看加扰会不会引起错误，从而快速解决问题
加扰有个缺点，加扰后本地debug版调试将不正常，比如断点也无法工作,所以debug版加扰仅用于验证release后能正常运行

为了加扰后支持uvc,增加如下配置
-keep class com.serenegiant.service.** {*;}
-keep class com.serenegiant.usb.** {*;}


解决crash.163加扰问题
http://crash.163.com/#dumply/q&a/read
16、集成后APP一运行就闪退，登录云捕后台看到如下一条crash日志：
java.lang.UnsatisfiedLinkError: 
JNI_ERR returned from JNI_OnLoad in "/data/data/com.cn.zh.device/app_lib/libbugrpt.so"
at java.lang.Runtime.load(Runtime.java:331)
at java.lang.System.load(System.java:982)
原因：  检查下工程的proguard配置，是否有添加对bugrpt的配置，如果没有配置请务必加上       
-keep class com.netease.nis.bugrpt.** {*;}


///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.06.01/////////////////////////////////////////////////////////////////////////////////////////////
想到一个点子:共享知识
在学习时经常遇到一些问题，没有地方咨询
可以做一个网站,列出小初高大研的课程书本pdf
用户可以提交疑问，也可以回复其他用户的疑问

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.05.30/////////////////////////////////////////////////////////////////////////////////////////////
.发现现在频繁的构造和析构BaseLooper,找出是mixOsd是引起的
 测试发现Camera.PreviewCallback是在Camera.open中回调的,
 以前AndroidDevice是在主UI线程打开camera,所以preview callback以及mixOsd都是在主UI线程做的
 现在是在VideoDeviceXXX子线程中打开camera,所以preview callback以及mixOsd在子线程中做的,导致mixOsd调用jni时频繁创建临时BaseLooper
//已解决，增加了gOsdTLSLooper

changes:
.新VideoDevice框架整合初步ok
 现在mipad能采用VideoDevice_MTK6572和VideoDevice_OpenGL作为视频源了
 VideoDevice_OpenGL出1080p能达到30fps,叠加有osd
 能切换vga/720p/1080p

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.05.15/////////////////////////////////////////////////////////////////////////////////////////////
.Android Handler.sendMessage不等待receiver处理消息，
 而仅仅是Pushes a message onto the end of the message queue after all pending messages before the current time

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.05.10/////////////////////////////////////////////////////////////////////////////////////////////
changes:
.ASSERT能dump出错行到日志了

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.04.27/////////////////////////////////////////////////////////////////////////////////////////////
python IDE:pyCharm
支持语法高亮，编辑，调试

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.04.20/////////////////////////////////////////////////////////////////////////////////////////////
一个比较好的开源h.264码流分析器
https://github.com/latelee/H264BSAnalyzer
作者个人主页，有些参考价值
http://www.latelee.org

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.03.30/////////////////////////////////////////////////////////////////////////////////////////////
.今天发现android c++下%C格式化大写字符不工作,会直接用'C'字符替换

///////////////////////////////////////////////////////////////////////////////////////////////////////
http://blog.csdn.net/weiqifa0/article/details/8799896
底层牛人

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.03.17/////////////////////////////////////////////////////////////////////////////////////////////
.windows ocx
//基本完满完成

.感觉BaseLooper可以作为一个sdk开放给第三方使用
 支持Android,ios和windows平台

.ShellTool::EatUpMessage中PeekMessage增加了wMsgFilterMin为WM_USER,可避免普通的windows message嵌套
 可简化app消息处理逻辑

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.23/////////////////////////////////////////////////////////////////////////////////////////////
osx上面没用好用的svn管理工具，只好学习使用svn command line了
非常好的svn command line入门指导
http://pointbeing.net/weblog/2009/03/command-line-subversion-tutorial-part-1.html
http://pointbeing.net/weblog/2009/04/command-line-subversion-tutorial-part-2.html
http://pointbeing.net/weblog/2009/06/command-line-subversion-tutorial-part-3.html

svn add xxx.cpp

提交时添加注释
svn commit -m "first"

查看状态
svn status

svn添加忽略文件和文件夹
先设置SVN默认的编辑器
export SVN_EDITOR=nano
然后，使用svn propedit svn:ignore ,用法如下
svn propedit svn:ignore /product
此时会出现一个VIM的编辑窗口，表示需要将某个文件加入到忽略列表里

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.20/////////////////////////////////////////////////////////////////////////////////////////////

http://www.easyicon.net/covert/534883/
.png转.ico

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.11/////////////////////////////////////////////////////////////////////////////////////////////
opencv人脸识别官方文档
http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html

AS logcat中不显示含p2p的日志
^((?!p2p).)*$

.rs485串行框架
 RS485Device提交请求到RS485Interface
 RS485Interface内置请求队列，依次处理


///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.09/////////////////////////////////////////////////////////////////////////////////////////////
360摄像机app做的非常好，很有参考价值

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.08/////////////////////////////////////////////////////////////////////////////////////////////
.基本完成onbon led display
 但rs485框架有待完成,还需要做多设备共存

SerialPortManager负责枚举和管理多个串口
SerialPort负责单个串口的业务
	每个485串口上面可以挂多个485设备，需要串行处理命令
 rs485传感器细化，在读取数据前1分钟通过USB对传感器供电，读取后数据后马上断电
 仅在需要读取传感器数据时通过gpio139对外供电
 gpio 139

changes:
.改进了HttpTool::ParseUrlParam,可以解析出带空格的字段了

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.07/////////////////////////////////////////////////////////////////////////////////////////////
android下使用libiconv.a转码utf8到gb2312
编写ios和android共用的c/c++库时 使用iconv的问题
http://blog.csdn.net/mortred1207/article/details/52915936
主要是CMakeLists.txt中增加
include_directories(${ANDROID_NDK}/sources/android/support/include)
${ANDROID_NDK}/sources/cxx-stl/llvm-libc++/libs/${ANDROID_ABI}/libandroid_support.a
可编译运行，但发现在mtk6572和小米手机的android上面iconv_open始终返回-1
	/*
	const char *from = "UTF8";
	const char *to = "GBK";
	iconv_t handle = iconv_open(to, from);
	DW("###iconv_open(%s,%s) handle=%p,error=%d(%s)", to, from, handle, errno, strerror(errno));
	if (handle !=(iconv_t)-1)
	{
		DW("iconv_open ok");
	}
	else
	{
		DW("iconv_open fail");
	}
	*/
//已解决,改用libicuuc.so转码成功，花了将近一天的时间解决此问题!


关于JAVA转码过程中奇数文本最后一个字符还是乱码情况解决 
http://blog.sina.com.cn/s/blog_3ed30fc4010007u6.html


http://blog.csdn.net/love_life2011/article/details/7086910
ARM开发板上iconv_open("utf-8", "gb2312") 调用失败的解决方法

.android rs485出现只能发数据，但收不到数据的问题
//已解决，加上SetComSpeed等初始串口参数就可以了

.mtk6572 rs485控制led display,能正常显示汉字了,rs485收发数据正常
//test ok

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.05/////////////////////////////////////////////////////////////////////////////////////////////
onbon led显示屏
rs232要简单很多，所以下面只考虑rs485
rs485串口设备框架
.camera上可能有多个rs485接口
.每个接口可能连接多个rs485设备，各设备必须采用不同的地址
.camera始终为rs485主控
.需要串行处理同一接口上的命令

RS485Manager
	RS485Interface(0,1或多个,是指camera上面的rs485接口)
		RS485Device(0,1或多个,是rs485外部设备，连接在rs485上面)

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.02.03/////////////////////////////////////////////////////////////////////////////////////////////
春节后第一天上班

.BaseLooper的message增加shared_ptr,保证handler的有效性

////////////////////////////////////////////////////////////////////////////////////////////
2017.01.09//////////////////////////////////////////////////////////////////////////////////
.增加了crc16
 是为了修改传感器id,需要用crc16校验

///////////////////////////////////////////////////////////////////////////////////////////////////////
2017.01.04/////////////////////////////////////////////////////////////////////////////////////////////
开源全景播放器
https://github.com/hanton/HTY360Player

传感器框架要重构
.直接在c++中收发数据并处理
.采用一个串口管理器，所有传感器的操作都由SerialMan来依次执行
.分离获取数据和后续处理
.每种传感器数据可设定获取频率

SerialPortManager负责枚举和管理多个串口
SerialPort负责单个串口的业务
	每个485串口上面可以挂多个485设备，需要串行处理命令
.rs485传感器细化，在读取数据前1分钟通过USB对传感器供电，读取后数据后马上断电

crash.163.com目前只能创建一个app,早已申请新的app,但163一直没回复，所以可考虑采用QQ的
https://bugly.qq.com
 
////////////////////////////////////////////////////////////////////////////////////////////
2016.12.30//////////////////////////////////////////////////////////////////////////////////
.发现用Microsoft Word能制作非常精良的.pdf文档,并且带书签
 在Word中另存为>PDF或XPS,在弹出的对话框中打开"选项",勾选创建书签时使用标题

///////////////////////////////////////////////////////////////////////////////////////////////////////
2016.12.26/////////////////////////////////////////////////////////////////////////////////////////////
linux serial port raw input/output
https://www.cmrr.umn.edu/~strupp/serial.html

现在ipcam在客户那里经常遇到问题，要用usb线才能看到android画面，很不方便,有必要做一个工具，通过网络就能看到android画面
通过screencap和sendevent就可以做到
http://blog.csdn.net/mad1989/article/details/38109689
已在mtk6572和小米手机上查看都有screencap和sendevent,所以是比较通用的
1|shell@android:/system/bin $ ls -l screen*                        
ls -l screen*                                                      
-rwxr-xr-x root     shell        9496 2016-11-12 19:26 screencap   
-rwxr-xr-x root     shell       38356 2016-11-12 19:26 screenshot  

shell@android:/system/bin $ ls -l *event
ls -l *event
lrwxr-xr-x root     shell             2016-11-12 19:26 getevent -> toolbox
lrwxr-xr-x root     shell             2016-11-12 19:26 sendevent -> toolbox

////////////////////////////////////////////////////////////////////////////////////////////
2016.12.13//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.在BaseHandler::Dump中
	if (child->IsLooper())
	{
		if (!child->MaybeLongBlock())
		{
			shared_ptr<BaseLooper> looper = dynamic_pointer_cast<BaseLooper>(child);
			//DV("this=0x%08x,looper=0x%08x(%s)", this,looper.get(),looper->mObjectName.c_str());
			looper->sendMessage(BM_DUMP,(WPARAM)(long)(level+1));
		}
	}
在ipad上测试时遇到过死锁的情况
在UI层点dump按钮，调用BaseHandler::DumpAll()
DumpAll()里面会AutoLock lock(&gCSBaseHandler);并向CameraDeviceLooper sendMessage(BM_DUMP)
此时CameraDeviceLooper恰好在析构某个对象，进入了BaseHandler::~BaseHandler(),它要求锁定gCSBaseHandler
从而导致死锁
//解决办法:sendMessage(BM_DUMP改为postMessage(BM_DUMP

////////////////////////////////////////////////////////////////////////////////////////////
2016.12.09//////////////////////////////////////////////////////////////////////////////////
移植kqueue时遇到的大坑
#define EVFILT_READ -1
#define EVFILT_WRITE -2
不明白为什么没采用bitmask来定义
linux和windows下一般都是用bitmask,这样rw可合并，但kqueue这样就不能合并

////////////////////////////////////////////////////////////////////////////////////////////
2016.12.07//////////////////////////////////////////////////////////////////////////////////
编译ios版bearcore时报thread-local storage is not supported for the current target
解决办法:project>info>ios deployment target选为9.0或以上版本就可以了

////////////////////////////////////////////////////////////////////////////////////////////
2016.12.06//////////////////////////////////////////////////////////////////////////////////
.BaseHandler postMessage时增加shared_ptr保活
//done

///////////////////////////////////////////////////////////////////////////////////////////////////////
2016.12.05/////////////////////////////////////////////////////////////////////////////////////////////
批量修改.java文件为utf8 without BOM的技巧

2016.11.30//////////////////////////////////////////////////////////////////////////////////

Android Style Message Passing Communicating between Threads using Message Queues.
https://github.com/Himmele/Mindroid.ecpp
http://blog.coldflake.com/posts/Android-style-Message-Passing/
感觉这个封装的有些过于复杂，并且没有很好的考虑对象生命周期
某些地方有一定的参考价值


https://github.com/haoxingeng/ise
ISE (Iris Server Engine) is a C++ framework for server programming.
Key features:
1. Cross-platform (Linux & Windows).
2. Multi-threaded.
3. Supports TCP and UDP.
4. Many cross-platform utilities.


http://en.cppreference.com/w/cpp/links/libs

///////////////////////////////////////////////////////////////////////////////////////////////////////
2016.11.29/////////////////////////////////////////////////////////////////////////////////////////////
发现郝新庚在github.com上面有个开源c++服务器引擎，有参考价值
他的电子日记本很好用
https://github.com/haoxingeng/ise

.打开映射的网络磁盘里的文件或右键菜单时，windows经常弹出security对话框
屏蔽的办法如下:
Go to Control Panel -> Internet Options -> Security -> Local Intranet -> Sites -> Advanced
Add the mapped drive or UNC path (eg. Z:\ or \\machine)
//test ok

///////////////////////////////////////////////////////////////////////////////////////////////////////
2016.11.22/////////////////////////////////////////////////////////////////////////////////////////////
aliyun oss sdk
阿里云对象存储（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全、低成本、高可靠的云存储服务。
用户可以通过调用API，在任何应用、任何时间、任何地点上传和下载数据，也可以通过用户Web控制台对数据进行简单的管理。
OSS适合存放任意文件类型，适合各种网站、开发企业及开发者使用。OSS C SDK提供了一系列接口方便用户使用OSS。
https://github.com/aliyun/aliyun-oss-c-sdk

oss sdk下载
https://help.aliyun.com/document_detail/32175.html

oss c sdk在嵌入式环境下如何编译
https://bbs.aliyun.com/read/260851.html?spm=5176.bbsr248504.0.0.Yz5MQ9
https://bbs.aliyun.com/read/248504.html?spm=0.0.0.0.MfVEam

.找到定位java和jni crash的办法了,都可定位到代码行和call stack
网易云捕crash.163.com,是免费的，并且没有风险
这些功能我们自己做也能做到，但网易已经做的很方便了，所以可直接使用
出现crash之后,它会自动上传crash信息到crash.163.com,非常好用
检测libbearcore.so crash代码行:
D:\Tools\Android\android-ndk-r11c-windows-x86_64\android-ndk-r11c\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin\arm-linux-androideabi-addr2line.exe -e D:\bear\share\bearcore\apk\obj\local\armeabi\libbearcore.so -a 00084bf0 
0x00084bf0
D:/bear/share/bearcore/apk/jni/core/MainLooper_Device.cpp:666

把D:\Tools\Android\android-ndk-r11c-windows-x86_64\android-ndk-r11c\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin加入path
arm-linux-androideabi-addr2line.exe -e D:\bear\share\bearcore\apk\obj\local\armeabi\libbearcore.so -a 00084bf0 

//增加了AppCrashLog,能检测到java层代码crash,并保持信息到sd卡/log/xxx,但没法检测到jni crash,在c++中try catch也没有效果
 当jni crash之后,在AS中logcat选择No Filters,并且不要过滤，显示所有日志，然后搜索backtrace字样，可看到大致的出错位置:
09-28 16:53:40.328 19032-19032/? I/DEBUG: backtrace:
09-28 16:53:40.328 19032-19032/? I/DEBUG:     #00  pc 00084bf0  /data/app-lib/com.maygion.bearcore-1/libbearcore.so (MainLooper_Device::OnJniMessage(CStringEx const&)+495)
09-28 16:53:40.328 19032-19032/? I/DEBUG:     #01  pc 0009523b  /data/app-lib/com.maygion.bearcore-1/libbearcore.so (_CDT::operator()(char const*, ...)+430)
09-28 16:53:40.328 19032-19032/? I/DEBUG: stack:
09-28 16:53:40.329 19032-19032/? I/DEBUG:          5302ad70  523aebeb  /data/app-lib/com.maygion.bearcore-1/libbearcore.so (MainLooper_Device::OnJniMessage(CStringEx const&)+490)
09-28 16:53:40.329 19032-19032/? I/DEBUG:          5302ad74  52566eaf  /data/app-lib/com.maygion.bearcore-1/libbearcore.so

////////////////////////////////////////////////////////////////////////////////////////////
2016.11.08//////////////////////////////////////////////////////////////////////////////////
.现在AndroidStudio2.2能采用cmake比较好的支持jni开发了,并且能方便的生成.aar来做sdk,所以决定重构工程，不再使用Android.mk的ndk-build方式
//已改

在工程中引入.aar
AndroidStudio>File>New>New Module>Import .JAR/.AAR Package

主要改动:
.CMakeLists.txt所有的jni c++代码放在arch/android/下面

////////////////////////////////////////////////////////////////////////////////////////////
2016.10.07//////////////////////////////////////////////////////////////////////////////////
changes:
.集成了pugixml 1.7,注意pugixml.cpp不要用stdafx.h,否则会报奇怪的错误
	在pugiconfig.hpp中启用两个宏
#ifdef _MSC_VER
	#define PUGIXML_NO_EXCEPTIONS
	#define PUGIXML_API __declspec(dllexport) // to export all public symbols from DLL
#endif

/////////////////////////////////////////////////////////////////////////////
2016.09.27///////////////////////////////////////////////////////////////////
.jni中有时Fatal signal 11 (SIGSEGV) at 0x0000010c (code=1), thread xxx
 并且没有任何上下文信息，这种错误比较难找
 有可能是访问空指针来调用函数或字段,0x0000010c应该是func或field的偏移量

////////////////////////////////////////////////////////////////////////////////////////////
2016.09.10//////////////////////////////////////////////////////////////////////////////////
changes:
.在BaseDataEndPoint增加超时机制,超时后自动关闭数据连接
 //已加，在mDataTimeout时间之内没有接收和发送数据时会主动断开连接

////////////////////////////////////////////////////////////////////////////////////////////
2016.09.09//////////////////////////////////////////////////////////////////////////////////
changes:
.HttpPostHandler可以接收上传超大文件了，细节有待整理

////////////////////////////////////////////////////////////////////////////////////////////
2016.09.08//////////////////////////////////////////////////////////////////////////////////
.httpserver要检测超时的http client

.像ajax那样，给http post做一个框架
 app可根据uri来注册http post的handler
 比如
 UploadApp.cgi由HttpPostHandler_UploadApp来处理
 UploadPicture.cgi由HttpPostHandler_UploadPicture处理
 UploadVideo.cgi由HttpPostHandler_UploadPicture处理

////////////////////////////////////////////////////////////////////////////////////////////
2016.08.24//////////////////////////////////////////////////////////////////////////////////
changes:
.BaseLooper增加了SetOwnerLooper
 在启动looper时自动调用Owner的CreateExitEvent

.强制要求Looper必须设定exit event
//是为了确保所有looper都安全退出

.子looper挂到父looper时，如果没有设定exit event,则自动设定owner looper
//在BaseHandler::AddChildHelper中增加了自动调用SetOwnerLooper
//app一般情况下不再需要主动调用SetExitEvent和CreateExitEvent,只需要调用AddChild就可以了
//接口简化很多

.修复了Device不能正常退出的问题
 Board_JJY::OnDestroy()中要清空mAudioSource和mVideoCapture
//当BaseHandler父对象采用成员变量shared_ptr缓存子handler时，在OnDestroy()中要清空share_ptr,否则app无法正常退出

////////////////////////////////////////////////////////////////////////////////////////////
2016.08.17//////////////////////////////////////////////////////////////////////////////////
.BaseHttpClientRequest没能正确析构，导致有内存泄漏
//已解决,mTcpClient置nullptr就可以了

.BaseHttpClientRequest对各种异常的处理,要始终返回结果
 连接失败
 超时

////////////////////////////////////////////////////////////////////////////////////////////
2016.08.13//////////////////////////////////////////////////////////////////////////////////
changes:
.BaseLooperImpl中的mCS改为mMessageLock
 //原因:mCS太顺手，很容易在普通类中采用这个名称，比如CloudP2PConnecter中就用到了
 所以在基础类BaseLooperImpl中要采用一个不容易重复的名称

////////////////////////////////////////////////////////////////////////////////////////////
2016.07.26//////////////////////////////////////////////////////////////////////////////////
.proc设计
//增加了ProcNode和BaseHandlerEx
 支持bool,int,DWORD,double和CStringEx数据
 现在每种类型对应一个OnProcDataSetter，感觉value全部采用CStringEx,按需要转换，这个更方便些
.增加了proc.xml接口，可以在浏览器中查看proc数据了

.OnProcDataGetter可以修改desc了，可动态修改desc

////////////////////////////////////////////////////////////////////////////////////////////
2016.07.06//////////////////////////////////////////////////////////////////////////////////
AS可以调试jni代码了，能断点
要加上如下字段
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            ndk {//加入后就才能正常的native debug
                debuggable = true
            }
        }

        debug {//加入后就才能正常的native debug,否则会报build type isn't JNI debuggable的问题
            debuggable = true
            jniDebuggable = true
        }

Android Studio NDK有很多坑
.在两个.so中分别都实现了某个jni接口，它不会报错，而是正常运行，结果实际调用的和期望的可能不同
目前AS中调用ndk-build来编译bearcore的，和eclipse的一样
要在AS工程中引用生成的libbearcore.so时,增如下几行
cFlags="-std=c++11 -I../../ -I../../arch/android -I ../../arch/linux  -I ../../apk/jni/core -I ../../core"
ldLibs "log -L ../../apk/libs/armeabi -lbearcore "
同时要把libbearcore.so复制到bearcore\as\app\src\main\jniLibs\armeabi
手工复制很容易出错，有待改为自动复制

.现在AS能调用libbearcore.so
 它在build.gradle中调用'ndk-build.cmd', '-C', "../../apk/jni"来直接使用eclipse工程中的Android.mk来编译jni
 但修改bearcore代码后，AS不能自动用新的.so,导致调试很不方便
 需要找到解决办法
//已解决,是AS的新特性Instant Run引起的，禁用后就可以了

http://blog.csdn.net/rodulf/article/details/51565075
Android Studio 更新成2.1.1 之后遇到一个问题，它有一个闪电运行的机制，出发点是好的，就是如果只是更新了一点点东西，那么我使用热部署来更新相应的activity 就好了。
但是我们经常遇到的情况是code 已经更新了，但是点击运行的时候还是提示 No changes To Deploy 。
这个非常影响我们的开发，我想还是还原为原来的方式，
解决办法：
点击File->Setting->Build,Execution，Deployment-》Instant Run
取消掉下面的的选项就可以了：
Enable Instant Run to hot swap code/resource changes on deploy(default enabled)

////////////////////////////////////////////////////////////////////////////////////////////
2016.07.05//////////////////////////////////////////////////////////////////////////////////
changes:
.对BaseHandler和BaseLoop增加了postDelayedMessage
 由于采用TIMER_ID_DELAY_MESSAGE timer来实现，所以目前每个handler只支持一个delayed message,如有需要后面再扩展

////////////////////////////////////////////////////////////////////////////////////////////
2016.07.04//////////////////////////////////////////////////////////////////////////////////
changes:
.移植了新版timewheel,定时很精确
 在TestLooper中2百万个timer,占用cpu基本为0%
 Debug版下创建timer比较慢,Release版快很多倍

.延时事件
//已加

////////////////////////////////////////////////////////////////////////////////////////////
2016.07.03//////////////////////////////////////////////////////////////////////////////////
.今天要把time wheel精度搞定

linux kernel time wheel add算法:
linux-4.6\kernel\time\timer.c
static void
__internal_add_timer(struct tvec_base *base, struct timer_list *timer)

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.26//////////////////////////////////////////////////////////////////////////////////
关于TimerManager::GetSlot定位问题
根据timeout来定位要插入的slot时，需要考虑当前各wheel的rewind steps
为直观起见,以时分秒为例来说明
timeout为90秒的timer
如果secondWheel的当前slot为10秒，则timer可插入minuteWheel.0
如果secondWheel的当前slot为50秒，则timer不能插入minuteWheel.0,而是要插入minuteWheel.1
算法如下
如果timeout小于60秒，则可直接插入minuteSecond
否则timeout - secondWheel.rewindSteps,当前slot为50秒时,rewindSteps为10秒,timeout-10=80

转到上级minuteWheel,每个slot表示60秒
timeout/60取整后为1,即插入minuteWheel.1
当切换到minuteWheel.1,在降级到secondWheel时，timeout对60取模,得到20，即插入secondWheel.20
minuteWheel.1和secondWheel.20这种都是相对于wheel当前slot位置的偏移，可回绕
由于低级wheel仅在slot为0才触发上级step(),所以在上述流程中低级wheel当前slot可保证为0


开源time wheel,不依赖其他文件，能直接在vs中编译
https://github.com/skywind3000/AsyncNet/blob/master/system/itimer.h
https://github.com/skywind3000/AsyncNet/blob/master/system/itimer.c

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.25//////////////////////////////////////////////////////////////////////////////////
bug fixed:
.TimeWheelSlot::Pop()中要调用mHeadNode->mPrev = nullptr;

changes:
.目前time wheel基本稳定，但精度有待改进

.timer精度有问题，原因是TimerManager::GetSlot定位不准确

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.22//////////////////////////////////////////////////////////////////////////////////
TimeWheelSlot::Detach()可能并不是好的设计
考虑如下场景
DoubleListNode *node = slot->Detach();
在node列表中某个timer handler处理时恰好调用到删除此node列表中的另一个timer时，由于mHeadNode已经为nullptr,所以会删除失败
void TimeWheelSlot::RemoveNode(DoubleListNode *node)
{
	if (!node || !mHeadNode)
	{
		return;
	}
...
//已测试，很容易此问题,会导致crash

	setTimer(1, 1);
	setTimer(2, 1);//故意让timerId 1和2处于同一slot中

	switch (timerId)
	{
	case 2://由于slot是后进先出，所以会先触发timerId 2,此时killTimer(1)会失败，但BaseHandler绑定的tagTimerInfo会被删除，导致后面触发timerId 1时crash
	{
		killTimer(1);
		killTimer(2);
		break;
	}
解决办法是不要采用Detach,而是就地依次处理timer

.测试两个looper在timer handler中对发sendMessage,看处理是否有问题
 TimerManager可能要设定为不可重入的,在TimerManager::ProcessTimer中加个bool即可
 一旦TimerManager::ProcessTimer可重入,当在某个timer handler中调用sendMessage时，它会再次调用TimerManager::ProcessTimer,导致timer无法正常工作
//test ok

Windows SendMessage文档中说了当线程阻塞在SendMessage中时，它不会再触发WM_TIMER事件
原文如下
https://msdn.microsoft.com/en-us/library/windows/desktop/ms644950(v=vs.85).aspx
The sending thread is blocked until the receiving thread processes the message. 
However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed
当阻塞在SendMessage里时，它只会继续处理nonqueued messages
https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx#routing
A messages that is posted to a message queue is called a queued message. 
These are primarily the result of user input entered through the mouse or keyboard, 
such as WM_MOUSEMOVE, WM_LBUTTONDOWN, WM_KEYDOWN, and WM_CHAR messages. 
Other queued messages include the timer, paint, and quit messages: WM_TIMER, WM_PAINT, and WM_QUIT. 
Most other messages, which are sent directly to a window procedure, are called nonqueued messages.
可看到WM_TIMER是queued message
所以可看到SendMessage时不再触发新的WM_TIMER事件

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.21//////////////////////////////////////////////////////////////////////////////////
.Debug版创建1M timer
	for(int i=0;i<1000*1000;i++)
	{
		setTimer(i, i);
	}
创建需要很长时间，创建完成之后运行时占用cpu为0%
看来time wheel效率果然很高
有待提高setTimer速度

.Release版创建1百万个timer,只需要1.6秒

changes:
.wheel timer初步可工作了，但误差有点大,有待改进

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.20//////////////////////////////////////////////////////////////////////////////////
高仿迅雷播放器,在vs2015下可编译运行，效果很好
http://www.cnblogs.com/Alberl/p/3407726.html


现在的PriorityQueue		mPriorityQueue;性能太低
在vs2013中设定500个interval为1000ms的timer,测试发现cpu占用就有点高了,1000个timer时,8核i7上占用cpu 13%
用profiler发现是大量的setTimer,killTimer频繁reheap引起的
急需改用time wheel来实现timer

新timer设计思路
.最大支持间隔为DWORD ms,即49.7天,最小粒度目前暂定10ms

--------------------------------------------------------------------
changes:
.mPriorityQueue timer相关代码全部移入BaseLooperImpl,为采用timewheel做准备

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.13//////////////////////////////////////////////////////////////////////////////////
高性能TimeWheel构思
.采用分级time wheel,
24小时
60分钟
60秒
1000ms
总共1144个slot
每个slot采用double list

TimeWheel
{
	array		mSlots[N];		//N分别为24,60,60,1000
	TimeWheel	*mParentWheel;	//上级,当本级回绕时通知上级进一格slot
}

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.09//////////////////////////////////////////////////////////////////////////////////
changes:
.Java_com_maygion_bearcore_Test_OnRecvMediaRecorderData每次都创建临时looper才能向DeviceMainLooper发消息，这个性能太低了
 可能的办法:构造一个本地的looper
//已增加了BaseLooper::newStackLooper()
非looper线程频繁发消息给looper时，可构造一个newStackLooper()
在非looper线程中如果要频繁向looper发送消息，每次都会创建临时looper
为提高性能，可在非looper线程中调用本接口来创建一个looper并缓存
stackLooper自己没有消息循环，只能向looper sendMessage或postMessage

////////////////////////////////////////////////////////////////////////////////////////////
2016.06.01//////////////////////////////////////////////////////////////////////////////////
.采用linux kernel类似的time whell算法来实现高性能timer
http://lwn.net/Articles/156329/
https://www.ibm.com/developerworks/cn/linux/l-cn-timers/
表 1. 定时器实现算法复杂度
实现方式	StartTimer		StopTimer	PerTickBookkeeping
基于链表	O(1)			O(n)		O(n)
基于排序链表O(n)			O(1)		O(1)
基于最小堆	O(lgn)			O(1)		O(1)
基于时间轮	O(1)			O(1)		O(1)
可看到time whell算法的性能是最高的

/////////////////////////////////////////////////////////////////////////////
2016.05.31///////////////////////////////////////////////////////////////////
changes:
.已测试了timerfd,可以定时触发,但它占用了一个file handler
 linux默认限制每个app只能打开1024个file
 ulimit -n xxxx可以提升限额，但肯定不能提升到100w个,所以不能用此方法来实现海量timer

 时间轮也许是个解决办法
比如实现秒级精度的timer,采用60个slot的时间轮，每个slot表示一秒
100w的timer基本被平均分配的话，每个slot不到1.67w个

linux kernel采用的time whell算法说明如下
http://lwn.net/Articles/156329/

https://www.ibm.com/developerworks/cn/linux/l-cn-timers/
在上面的水表中，为了表示度量范围，分成了不同的单位，比如 1000，100，10 等等，
相似的，表示一个 32bits 的范围，也不需要 2^32 个元素的数组。
实际上，Linux 的内核把定时器分为 5 组，每组的粒度分别表示为：
1 jiffies，256 jiffies，256*64 jiffies，256*64*64 jiffies，256*64*64*64 jiffies，
每组中桶的数量分别为：256，64，64，64，64，这样，在 256+64+64+64+64 = 512 个桶中，表示的范围为 2^32 。
有了这样的实现，驱动内核定时器的机制也可以通过水表的例子来理解了，就像水表，每个粒度上都有一个指针指向当前时间，
时间以固定 tick 递增，而当前时间指针则也依次递增，如果发现当前指针的位置可以确定为一个注册的定时器，就触发其注册的回调函数。 
Linux 内核定时器本质上是 Single-Shot Timer，如果想成为 Repeating Timer，可以在注册的回调函数中再次的注册自己


.测试iocp和epoll的性能
 采用两个线程，一个做发送
 iocp用post,epoll用fd trigger
 while(1)
 {
   post/fd trigger
 }
 
 另一个做接收
 while(1)
 {
   getqueuexxx/epoll_wait
 }
 
 看它们每秒能调用多少次

/////////////////////////////////////////////////////////////////////////////
2016.05.30///////////////////////////////////////////////////////////////////
可以仿照linux /proc那样，用BaseHandler机制搞一个tree node
可展示app当前的运行状态数据，可修改
可以枚举所有的node,每个node有get/set和desc等接口
做一个网页,提供editBox和set
可修改指定path的数据
一个很好的用途是修改指定模块的log级别
/app/rtsp/loglevel     xxx

Proc框架采用weekptr来引用,由于各BaseHandler可能处于不同的looper中，所以Proc框架采用sendMessage来get/set等收集和修改
这是一个很有用的功能

/////////////////////////////////////////////////////////////////////////////
2016.05.23///////////////////////////////////////////////////////////////////
#include <Windows.h>
#include "tlhelp32.h"

//刷新任务栏图标
void RefreshTaskbarIcon()
{
	//任务栏窗口
	HWND hShellTrayWnd = ::FindWindow(_T("Shell_TrayWnd"), NULL);
	//任务栏右边托盘图标+时间区
	HWND hTrayNotifyWnd = ::FindWindowEx(hShellTrayWnd, 0, _T("TrayNotifyWnd"), NULL);
	//不同系统可能有可能没有这层
	HWND hSysPager = ::FindWindowEx(hTrayNotifyWnd, 0, _T("SysPager"), NULL);
	//托盘图标窗口
	HWND hToolbarWindow32=NULL;
	if (hSysPager)
	{
		hToolbarWindow32 = ::FindWindowEx(hSysPager, 0, _T("ToolbarWindow32"), NULL);
	}
	else
	{
		hToolbarWindow32 = ::FindWindowEx(hTrayNotifyWnd, 0, _T("ToolbarWindow32"), NULL);
	}
	if (hToolbarWindow32)
	{
		RECT r;
		::GetWindowRect(hToolbarWindow32, &r);
		int width = r.right - r.left;
		int height = r.bottom - r.top;
		//从任务栏中间从左到右 MOUSEMOVE一遍，所有图标状态会被更新
		for (int x = 1; x<width; x++)
		{
			for (int y = 0; y < height; y += 4)
			{
				::SendMessage(hToolbarWindow32, WM_MOUSEMOVE, 0, MAKELPARAM(x, y));
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
2016.05.20///////////////////////////////////////////////////////////////////
.android app ui demo
http://netease.im/im-sdk-demo
user:xwpcom sn:xxxxxx
其android demo可编译运行，画面比我们自己的要好看,有很多布局可供参考

http://www.rongcloud.cn/downloads
user:xwpcom@163.com sn:xxxxxx
这个画面也可以参考


/////////////////////////////////////////////////////////////////////////////
2016.05.19///////////////////////////////////////////////////////////////////
.快速定位memory leak
f:\bear\demo\testredis\testredis.cpp(84) : {271} normal block at 0x00786280, 4 bytes long.
{271}表示是第271次分配的内存有泄漏
可加上_CrtSetBreakAlloc(271);这样在执行271次分配时,vc++就会自动中断，可定位代码行和call stack

.#include <atomic>
atomic_bool atomic<bool>
atomic_char atomic<char>
atomic_uchar atomic<unsigned char>
atomic_int atomic<int>
atomic_uint atomic<unsigned int>
atomic_long atomic<long>
atomic_ulong atomic<unsigned long>
atomic_llong atomic<long long>
atomic_ullong atomic<unsigned long long>
atomic_wchar_t atomic<wchar_t>

.linux app性能统计
编译时增加-pg参数
运行gcc -lstdc++ -std=c++11 -pg -o t main.cpp
运行./t会生成 gmon.out
运行gprof t gmon.out可打印各api调用的频繁，占用的时间等

/////////////////////////////////////////////////////////////////////////////
2016.05.17///////////////////////////////////////////////////////////////////
Android.mk千万不能采用utf8 with BOM来保存，否则ndk-build不会正确编译它

bug fixed:
.注意looper子类::OnMessage要调用__super::OnMessage
 如果不调用基类来处理基本消息，则会引起各种问题，比如looper无法正常退出，timer不工作等

////////////////////////////////////////////////////////////////////////////////////////////
2016.05.16//////////////////////////////////////////////////////////////////////////////////
changes:
.looper中OnTimer改为onTimer
.BaseLooperImpl::OnMessage和BaseHandler::OnMessage重复调用了onTimer
 //已屏蔽BaseLooperImpl::OnMessage中调用onTimer,统一在BaseHandler::OnMessage中调用

/////////////////////////////////////////////////////////////////////////////
2016.05.11///////////////////////////////////////////////////////////////////
.dt.cpp中精确到ms的办法
 windows下使用GetLocalTime SYSTEMTIME sysTime;
 linux下办法:http://stackoverflow.com/questions/24991358/c-equivalent-for-getlocaltime-in-linux-with-milliseconds

/////////////////////////////////////////////////////////////////////////////
2016.05.09///////////////////////////////////////////////////////////////////
为简单起见，可都采用vs2015 IDE,但使用vs2013的v120_xp编译器,但发现此时没法断点调试
//已解决,在选择v120_xp之后，要在Linker>Debugging>Generate DebugInfo中选中YES

/////////////////////////////////////////////////////////////////////////////
2016.05.07///////////////////////////////////////////////////////////////////
changes:
.增加了ListAjaxCommand.xml
 可列出所有ajax command信息

/////////////////////////////////////////////////////////////////////////////
2016.04.25///////////////////////////////////////////////////////////////////
发现cmake的多目录工程管理非常好用,并且各project能够自动依赖
已测试发现当修改bearcore后cmake能自动重新编译依赖bearcore的device工程
太棒了!

cd /mnt/bear/bin/pclinux/debug
./c.sh
./ds

changes:
.pc linux下能用http下载超大文件了
 主要是在BaseTcpClient_Linux EAGAIN时注册writable事件
 在收到writable事件时再DisableListenWritable()

/////////////////////////////////////////////////////////////////////////////
2016.04.22///////////////////////////////////////////////////////////////////
设计新网页只需要参考如下两个网站即可
http://getbootstrap.com/components/
http://www.w3schools.com/bootstrap

bootstrap和jquery都有min版本，不方便调试和修改,我们没有必要使用,直接用普通版就可以了

.div hover背景色只盖住一部分的解决办法:
F:\jjy\bin\web\res\jqueryui\css\custom-theme\jquery-ui-1.10.0.custom.css
line 258增大background-position: 0 -100px;

////////////////////////////////////////////////////////////////////////////////////////////
2016.04.20//////////////////////////////////////////////////////////////////////////////////
.把Signal集成到BaseDataEndPoint,这样才能方便的统一socket和p2p
.计划采用BaseLooper替换现有的webrtc thread+message框架

changes:
.BaseLoop增加了postDelayedMessage
 目前主要用来延时退出app
 在Device的AjaxHandler_Exit中用到了
 为避免BaseHandler提前失效导致crash,只对looper提供了postDelayedMessage
 BaseHandler如有需要可用setTimer模拟实现

////////////////////////////////////////////////////////////////////////////////////////////
2016.04.19//////////////////////////////////////////////////////////////////////////////////
changes:
.采用MFC静态库时，Device调用会crash
 //已解决,bearcore改用MFC动态库即可
.发现不需要用postbuild.dat来复制生成的文件
 而是把bearcode project加到device.sln中
 bearcode Output Directory设定为$(SolutionDir)..\bin\
 这样Device直接引用就可以了

.编译pc linux版ok,可运行
.编译hi3516版ok,应该能运行

/////////////////////////////////////////////////////////////////////////////
2016.04.14///////////////////////////////////////////////////////////////////
changes:
.花了4天时间，基本解决了ffmpeg mux/demux h.265 .mp4的技术问题
 有待细化的工作:aac,AV同步,vod seek,这些应该简单

/////////////////////////////////////////////////////////////////////////////
2016.04.11///////////////////////////////////////////////////////////////////
 http://tools.ietf.org/html/rfc3550

 rtp AAC
 RTP Payload Format for Transport of MPEG-4 Elementary Streams
 http://tools.ietf.org/html/rfc3640

 RTP Payload Format for MPEG-4 Audio/Visual Streams
 http://tools.ietf.org/html/rfc6416

/////////////////////////////////////////////////////////////////////////////
2016.04.05///////////////////////////////////////////////////////////////////
 changes:
.在BaseHandler::~BaseHandler()里增加了调用OnDestroy(),可确保所有的BaseHandler至少调用一次OnDestroy()
 在析构时删除了所有timer,避免消息队列中存在过时的timer导致crash

/////////////////////////////////////////////////////////////////////////////
2016.04.01///////////////////////////////////////////////////////////////////
changes:
.增加了BaseHandler::FindObject(string url)
 BaseHandler::mObjectName为关键字
 url中可用/分隔多层
 AddChild可指定objectName
 以current looper为顶点,以
//test ok

/////////////////////////////////////////////////////////////////////////////
2016.03.31///////////////////////////////////////////////////////////////////
changes:
.BaseHandler默认mPassive应该为true
 只有windows下tcp server和tcp client有未决的概念
 其他都没有此概念
 已增加了SetActiveObject()和SetPassiveObject(),并检测mHasSetActiveOrPassive
//已改, 已删除SetPassiveObject()

.增加了BM_CREATE,

/////////////////////////////////////////////////////////////////////////////
2016.03.30///////////////////////////////////////////////////////////////////
.getaddrinfo_a异步解析dns成功
 见Test::TestAsyncDns()

 数据收发采用抽象的BaseDataEndPoint

/////////////////////////////////////////////////////////////////////////////
2016.03.29///////////////////////////////////////////////////////////////////
changes:
.BaseTcpClient_Linux主动连接test ok

.BaseTcpClient_Linux处理连接超时
//test ok,ubuntu自动20秒超时

.boost可启用或禁用
 大部分app只用c++ auto/shared_ptr即可，不需要用到boost lockfree,所以需要能禁用boost

-------------------------------------------------------------------
.异步域名解析(windows上可参考master中的WSAAsyncGetHostByName,WSACancelAsyncRequest,linux可使用getaddrinfo_a)
	{
		struct gaicb *reqs[1];
		reqs[0] = (gaicb *)calloc(1,sizeof(gaicb));
		int ret=getaddrinfo_a(GAI_WAIT, reqs, 1, NULL);	//lib: -lanl
	}
	linux下有用的api:timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via file descriptors
//已测试getaddrinfo_a ok

.linux下运行时的NetLooper和GameLooper互相强引用，退出顺序有待研究
[03.28 20:33:55.568][SetEvent(NetLooper)]    
[03.28 20:33:55.568][SetEvent(GameLooper)]   
[03.28 20:33:55.568][~GameLooper]            
[03.28 20:33:55.568][~NetLooper]             
[03.28 20:33:55.569][~BaseHttpServer]        
[03.28 20:33:55.569][~BaseTcpServer_Linux]   
[03.28 20:33:55.569][~MainLooper]            
[03.28 20:33:55.569][DumpAll# is empty]      

/////////////////////////////////////////////////////////////////////////////
2016.03.28///////////////////////////////////////////////////////////////////
.linux下backtrace能打印call stack,但c++ api是编码后的形式，不方便查看
#ifdef _MSC_VER
int backtrace(void **buffer, int size){return 0;}
char **backtrace_symbols(void *const *buffer, int size){return nullptr;}
void backtrace_symbols_fd(void *const *buffer, int size, int fd){}

#else
#include <execinfo.h>
#endif
void PrintStack()
{
	int j, nptrs;
#define SIZE 100
	void *buffer[100];
	char **strings;

	nptrs = backtrace(buffer, SIZE);
	printf("backtrace() returned %d addresses\n", nptrs);

	/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
	would produce similar output to the following: */

	strings = backtrace_symbols(buffer, nptrs);
	if (strings == NULL)
	{
		perror("backtrace_symbols");
		return;
	}

	for (j = 0; j < nptrs; j++)
		printf("%s\n", strings[j]);

	free(strings);
}

changes:
.epoll能收到chrome http request了
.整理了BaseLooper_Linux和BaseLooper_Windows,共用代码移到BaseLoopImpl
.同步epoll版本
//已完成
 
/////////////////////////////////////////////////////////////////////////////
2016.03.27///////////////////////////////////////////////////////////////////
.有必要研究一下linux下的timerfd,eventfd
int timerfd_create(int clockid, int flags);
int timerfd_settime(int fd, int flags,const struct itimerspec *new_value,struct itimerspec *old_value);
int timerfd_gettime(int fd, struct itimerspec *curr_value);

int eventfd(unsigned int initval, int flags);

man threads中列出一些not thread safe的api和相应的thread safe版本的api,可研究来何用来提高app稳定性

linux event

changes:
.linux版可编译运行了(epoll net有待整理)
/////////////////////////////////////////////////////////////////////////////
2016.03.25///////////////////////////////////////////////////////////////////
changes:
.MainLooper初步增加WebServer,运行ok
.增加了Ajax command扩展框架,test ok
 增加新命令很方便了
 atexit(BaseAjaxHandler::Destroy);//atexit非常好用,可用来在app退出时自动释放框架占用的内存
.ajax command约定:
 大小写敏感
 必须以小写的.xml结尾

.在cs hpptsvr基础上重构WebServer
 目录net/webserver
 旨在提供一个通用版web server框架
 可由各app在具体应用时扩展功能，而不需要修改web server底层代码
 cs在增加ajax command时要直接修改底层代码，这个是很不好的设计,正确的做法是框架要提供注册接口，由app主动注册
.集成webServer,可查询和控制app行为
 为了不影响现在的parent/child框架,此webServer不能直接设为looper的child,而是要作为member变量特殊处理
//已做

/////////////////////////////////////////////////////////////////////////////
2016.03.24///////////////////////////////////////////////////////////////////
网页参考
http://getbootstrap.com
http://jqueryui.com/download

腾讯游戏开发技术圈
http://gad.qq.com/college/group/94


网络服务器开发总结
http://gad.qq.com/college/articledetail?cid=24
http://my.oschina.net/u/181613/blog/596022?fromerr=lm4HUCda
提高服务器性能的办法:
.连接缓冲区内存分配常采用slab内存分配策略，可以直接实现slab算法（如memcached），但推荐直接采用jemalloc与tcmalloc等（如redis）
.listen_fd有可读事件时不应仅accept一次，而最好循环accept直到其返回-1。
.异步连接
 异步连接时首先需要创建socket并设置为非阻塞，然后connect连接该套接字即可。
 若connect返回0则表示连接立即建立成功；否则需要根据errno来判断是连接出错还是处于异步连接过程；
 若errno为EINPROGRESS则表示仍然处于异步连接连接，需要epoll来监听socket的可写事件（注意不是可读事件）。
 当可写后通过getsockopt来获取错误码（即getsockopt(c->sfd, SOL_SOCKET, SO_ERROR, &err, (socklen_t*)&len);），
 若getsockopt返回0且错误码err为0则表示连接建立成功，否则连接失败。
.异步域名解析
 对于异步完成后产生指定信号，需要服务器进行捕获该信号并进一步解析出IP地址。
 为了能够在epoll框架中统一处理网络连接、进程间通信、定时器与信号等，linux系统提供eventfd、timerfd与signalfd等。
 在此创建dns_signal_fd = signalfd(-1, &sigmask, SFD_NONBLOCK|SFD_CLOEXEC));并添加到epoll中；当异步完成后产生指定信号会触发dns_signal_fd可读事件；由read函数读取到signalfd_siginfo对象，并通过gai_error函数来判断异步域名解析是否成功，若成功则可遍历gai->ar_result得到IP地址列表。
.热更新
 热更新是指更新可执行文件时正在运行逻辑没有受到影响（如网络连接没有断开等），但新网络连接处理将会按更新后的逻辑处理（如玩家登陆等）。热更新功能对接入层服务器（如游戏接入服务器或nginx等）显得更加重要，因为热更新功能大部分时候可以避免停机发布，且随时重启而不影响当前处理连接。
 WeQuiz手游接入服务器中热更新的实现要点:
（1）在父进程中创建listenfd与eventfd，然后创建子进程、监听SIGUSR1信号并等待子进程结束；而子进程将监听listenfd与eventfd，并进入epoll循环处理。
（2）当需要更新可执行文件时，发送SIGUSR1信号给父进程则可；当父进程收到更新信号后，其通过eventfd来通知子进程，
	同时fork出新进程并execv新可执行文件；此时存在两对父子进程。
（3）子进程通过epoll收到eventfd更新通知时，则不再监听并关闭listenfd与eventfd。由于关闭listenfd则无法再监听新连接，
	但现有网络连接与处理则不受影响，不过其处理仍是旧逻辑。当所有客户端断开连接后，epoll主循环退出则该子进程结束。
	值得注意的是，由于无法通过系统函数来获取到epoll处理队列中的连接数，则需要应用层维持当前连接数，当其连接数等于0时则退出epoll循环。
	此时新子进程监听listenfd并处理新网络连接。
（4）当旧父进程等待到旧子进程退出信号后则也结束，此时仅存在一对父子进程，完成热更新功能。
.过载保护
 
.连接过期
 timerfd_settime
 连接过期是指客户端连接在较长时间内没有与服务器进行交互。为防止过多空闲连接占用内存等资源，故网络服务器应该有机制能够清理过期网络连接。
 目前常用方法包括有序列表或散列表等方式来处理，但对后端服务器来说，轮询总不是最佳方案。
 QQ宠物与WeQuiz接入层通过每一连接对象维持唯一timerfd描述符，而timerfd作为定时机制能够添加到epoll事件队列中，
 当接收该连接的网络数据时调用timerfd_settime更新空闲时间值，若空闲时间过长则epoll会返回并直接关闭该连接即可。
 虽然作为首次尝试（至少本人没有看到其它项目中采用过），但接入服务器一直以来都比较稳定运行，应该可以放心使用。

.调试
网络服务器开发调试大部分情况都可以通过日志来完成，必要时可以通过gdb调试，当然也可以在Linux系统下直接使用eclipse/gdb来可视化调试。
当程序异常时，有core文件直接使用gdb调试，如bt full查看全栈详细信息或f跳到指定栈p查看相关信息；
没有core文件时则可以查看/var/log/message得到地址信息，然后通过addr2line或objdump来定位到相关异常代码。
对于服务器来说，内存泄漏检测也是必不可少的，其中valgrind为最佳的内存泄漏检测工具。
此外，其它常用的调试工具（编译阶段与运行阶段）有nm、strings、strip、readelf、ldd、pstack、strace、ltrace与mtrace等。

.压力测试
对于http服务器，常用ab或siege等工具进行压测，如./siege –c 500 –r 10000 –b –q http://10.193.0.102:8512/petcgi/xxx?cmd=yyy。
对于其它类型服务器一般都需要自己编写压测客户端（如redis压测工具），常用方法是直接创建多线程，每一线程使用libevent创建多连接与定时器等来异步请求与统计。
此外，若需要测试大量连接数，则可能需要多台客户机或创建多个虚拟ip地址。

.优化
网络服务器优化涉及算法与技术等多个方面。
算法方面需要根据不同处理场景来选择最优算法，如九宫格视野管理算法、跳跃表排行算法与红黑树定时器管理算法等，
此外，还可以通过有损服务来设定最佳方案，如WeQuie中采用到的有损排行榜服务。
技术方面可以涉及到IO线程与逻辑分离、slab内存管理（如jemalloc与tcmalloc等）、socket函数（如accept4、readv、writev与sendfile64等）、
socket选项（如TCP_CORK、TCP_DEFER_ACCEPT、SO_KEEPALIVE、TCP_NODELAY与TCP_QUICKACK等）、新实现机制（如aio、O_DIRECT、eventfd与clock_gettime等）、
无锁队列（如CAS、boost::lockfree::spsc_queue与zmq::yqueue_t等）、异步处理（如操作mysql时采用异步接口库libdrizzle、webscalesql或mongodb
或redis异步接口与gevent类异步框架等）、协议选择（如http或pb类型）、数据存储形式（如mysql的blob类型、mongodb的bjson类型或pb类型等）、
存储方案（如mysql、mongodb、redis、bitcask与leveldb及hdfs等）、避免惊群（如加锁避免）、用户态锁（如nginx通过应用层的CAS实现（更好跨平台性））、
网络状态机、引用计数、时间缓存、CPU亲缘性与模块插件形式（如python、lua等）。
常用的调优工具有valgrind、strace、perf与gprof及google-perftools等，如valgrind的callgrind工具，
可以在需要分析代码段前后加上CALLGRIND_START_INSTRUMENTATION; CALLGRIND_TOGGLE_COLLECT; CALLGRIND_TOGGLE_COLLECT; 
CALLGRIND_STOP_INSTRUMENTATION;，然后运行valgrind --tool=callgrind --collect-atstart=no --instr-atstart=no ./webdir即可，
得到分析结果文件还可用Kcachegrind可视化展示。
除了提高服务器运行效率外，还可以通过一些开发包或开源库来提高服务器开发效率，如采用boost库管理不定长对象的共享内存、python协程与go框架等

（6）监控
Linux在服务器监控方面工具非常丰富，
包括ps、top、ping、traceroute、nslookup、tcpdump、netstat、ss、lsof、nc、vmstat、iostat、dstat、ifstat、mpstat、
pidstat、free、iotop、df、du、dmesg、gstack、strace与sar（如-n/-u/-r/-b/-q等）及/proc等，
如ps auxw查看进程标记位（一般地D阻塞在IO、R在cpu、S表示未能及时被唤醒等），gstack pid查看进程当前栈信息，
ss -s查看连接信息，sar -n DEV 1 5查看包量，sar -r 1 5查看内存使用情况，vmstat 1 5查看进程切换频率，
iotop或iostat -tdx 1或dstat -tclmdny 1查看磁盘信息与mpstat 2查看CPU信息及/proc/net/sockstat查看socket状态等。
此外有时最有效的是服务器日记文件。

--------------------------------
telnet rfc文档很简单
http://tools.ietf.org/html/rfc854



/////////////////////////////////////////////////////////////////////////////
2016.03.23///////////////////////////////////////////////////////////////////
.object tree,life cycle management
 每个object有且仅有一个parent,root object的parent为nullptr
 object可以有多个child object,多个object可形成object tree,不能有环
 .提供object tree dump机制，可辅助调试
  dump采用消息机制，可保证跨looper运行时的安全
.object tree销毁时序:保证child object在parent之前析构
 正常运行时,parent对child做弱引用(不能做强引用，原因见下)
 child可分为两种类型，一种是自主型，另一种是被动型
 自主型是指生命周期由object自己的当前的未决业务来保证，当没有未决业务时能自动销毁，比如BaseTcpClient,
 BaseTcpClient在有未完成的IoContext时会一直存在,在所有IoContext已完结时能自毁
 被动型是指对外提供服务，但没有未决业务这个概念,比如GameTcpHandler
 如果parent对所有child一视同仁做强引用，则自主型child在业务完结时不能自动销毁
 如果parent不对被动型child做强引用，则被动型child在创建之后马上上自毁了
 发现被动型可以用mSelfRef来保活，当BM_DESTROY时再自毁
 所以app中parent对child只做弱引用,而child对parent做强引用

 app结束时,parent对所有child发BM_DESTROY,收到BM_DESTROY时主动型child会取消所有未决业务，被动型child会清除mSelfRef，所以都可保证完结
 当顶级looper定时检测到use_count()为1表示没有child引用它，此时可安全退出looper
 
 这里所说的object在代码中由BaseHandler来实现,而BaseObject只是一个最简化的基类

.被动型mSelfRef的处理
 在AddChild时会设定被动型object的mSelfRef
 在收到BM_DESTROY时会清除mSelfRef
 要主动销毁时，可调用PostDispose(mSelfRef);
 建议不要主动调用postMessage(BM_DESTROY),原因如下:
 多次调用PostDispose(mSelfRef)是无害的，但多次postMessage(BM_DESTROY)时，第一个BM_DESTROY销毁，后面的BM_DESTROY会导致crash

changes:
.基本完成上述的parent/child框架
 发现有时NetLooper不能正常退出,现象是NetLooper已退出线程，但没调用NetLooper的析构
 导致也没析构MainLooper
//增加了_CONFIG_TEST_BASE_HANDLER,可检查 object leaks,发现还是有leaks
//已解决，犯了个低级错误,
 在BaseLooper::CanQuitLooperNow()直接return true,导致没调用到BaseLooper_Windows::CanQuitLooperNow()
 修改后问题不再重现

.写一个client test app,自动来测试server,现在用chrome按F5,不太方便
//已创建Monkey工程做压力测试

.object跨looper运行
.object有依赖时的退出顺序

/////////////////////////////////////////////////////////////////////////////
2016.03.22///////////////////////////////////////////////////////////////////
changes:
.BaseHandler::PostDispose改用template实现
 PostDispose用来解决如下问题
 假定ObjectA强引用ObjectB
 当ObjectB回调ObjectA的api时，有可能ObjectA需要释放对ObjectB的强引用
 如果ObjectA直接释放,则当控制返回到ObjectB时，OjbectB已经析构，但ObjectB没意识到这一点，仍然引用this来做操作，造成crash
 PostDispose的解决办法:
 new一个结构来缓存指向ObjectB的shared_ptr,投递消息给looper,looper在消息时删除shared_ptr
 //test ok

.BaseLooper是不是一种BaseHandler
 BaseLooper和BaseHandler有很多接口相同,把它们统一起来会比较方便
 但BaseLooper是BaseHandler的基石，它不同于普通的BaseHandler
 BaseLoop和BaseLooper也要整理
//已解决,BaseLoop从BaseHandler继承了

.需要实现一个框架，可设定多个object之间的依赖关系,当app退出时自动根据依赖关系来完结各object业务
 可归纳为消息通知,即制定好规则后在合适的时机发送消息

.object的树形结构和依赖绑定

c++ object生命周期管理
object实例对象存在的意义
app创建object都是为了实现某个功能需求，当功能需求已满足或消失后就不再需要此object,也就是说可以清除object了


object之间的关系
怎么定义多个objects之间的关系，有几种可能
按tree树形结构来定义的话，每个object有一个parent,有0个或多个child
按group群结构来定义,则不存在parent/child关系，而是按照StrongRef,WeakRef即强/弱引用比较直观
tree是group的一个特例
为简化起见，可采用tree来实现app的object管理
app的根从main入口函数开始,以Device app来说,root object就是MainLooper

一般来说，创建两个object的关系是比较简单的，难点在于何时解除关系
感觉BaseHandler中parent/child和ref应该独立出来
parent/child表示的是在object tree中的层次
ref表示的是业务依赖
这两者有时是一致的，但有时没有关联

parent和child的强弱引用
哪方对另一方做强引用，还是双方互相强引用，需要分析一下
parent对child做强引用，看起来天经地义,但会遇到问题
比如在app结束时,为安全退出app,所有object都必须完结业务并销毁

想到了一个比较好的idea
正常运行时,parent对child做强引用
app结束时,parent对所有child添加一个弱引用(仅供调试使用),然后通知所有child反转强引用,即child对parent做强引用,parent不再强引用child
当顶级looper定时检测到use_count()为1表示没有child引用它，此时可安全退出looper

parent对所有child添加一个弱引用是为了方便调试，比如当有bug导致looper一直不能退出时，可递归查询是哪些child引起的
--------------------------------------------------------------------------------------

https://msdn.microsoft.com/en-us/library/hh279669.aspx
Whenever possible, use the make_shared (<memory>) function to create a shared_ptr when the memory resource is created for the first time. 
make_shared is exception-safe. It uses the same call to allocate the memory for the control block and the resource, 
and thereby reduces the construction overhead. If you do not use make_shared, 
then you have to use an explicit new expression to create the object before you pass it to the shared_ptr constructor.
在我看来make_shared主要是不需要主动调用new

.C++开源代码覆盖率工具OpenCppCoverage
用法
cd f:\jjy\device
OpenCppCoverage --sources . -- ../bin/DeviceD.exe
会在device目录下生成测试结果网页
.一个精通测试的牛人博客http://www.cnblogs.com/coderzh

.利用vs展开macro
 选中需要展开的代码文件，右键 - 属性 - C/C++ - Preprocessor
 Generate Preprocessed File 设置 Without Line Numbers (/EP /P) 或 With Line Numbers (/P)
 关闭属性对话框，右键选中需要展开的文件，右键菜单中点击：Compile
 编译过后，会在源代码目录生成一个后缀为.i的文件

 
 http://www.cnblogs.com/coderzh/p/ThreadSanitizer.html
 在ubuntu 10.04和14.04上面测试都失败
g++ -fsanitize=thread -fPIE -pie -g t.cpp -o ./t -ltsan
运行时报:
FATAL: ThreadSanitizer can not mmap the shadow memory (something is mapped at 0x555a27e1c000 < 0x7cf000000000)
FATAL: Make sure to compile with -fPIE and to link with -pie.

 gcc -fsanitize=thread -fPIE -pie -g t.cpp -o ./t -ltsan  -Wl,-Ttext-segment=0x855555000000
 运行时报
 Segmentation fault
没google到解决办法

/////////////////////////////////////////////////////////////////////////////
2016.03.21///////////////////////////////////////////////////////////////////
.bug fixed:GameLooper会提前析构导致crash
//已解决,由于目前GameTcpClient的OnClose有可能延时，所以需要等待GameTcpServer完结后才能通知GameLooper结束
 在NetLooper::CanQuitLooperNow()中mTcpServer为nullptr后才调用一次mGameLooper->postMessage(BM_NET_LOOPER_FINISH);
 归根结底，还是由looper依赖引起的
 看来要想出一种通用的办法来解决线程依赖时的退出先后控制
 依赖关系树:
.GameTcpServer需要等待所有GameTcpHandler完结才能退出
.NetLooper需要等待GameTcpServer完结才能退出
.GameLooper需要等待GameTcpServer完结才能退出
 看起来好像可采用sigslot机制，在析构中触发消息，跨线程也可使用

.非常好用的工具，可实时显示api调用的频次,比如vs2015自带的好用
 启用方法:安装MicroProfiler之后,在SolutionExplorer中右击prject,勾上Enable Profiling,编译运行时MicroProfiler对话框会自动显示出来
 禁用:在SolutionExplorer中右击prject,点Remove Profiling Support即可
 bug解决:发现有时编译一直报__penter没有定义，是MicroProfiler混乱引起的，解决办法:enable再disable Profiling即可
 发现MicroProfiler是采用__penter和__pexit来实现的,由vs编译开关来支持,见https://msdn.microsoft.com/en-us/library/c63a9b7h.aspx
 http://www.codeproject.com/Articles/800172/A-Simple-Cplusplus-Profiler-on-x
 https://visualstudiogallery.msdn.microsoft.com/133d5764-b32b-4ec9-8ee8-5546eca64584
 MicroProfiler offers unique ability to perform analysis and deliver it in real-time. 
 You will not have to endlessly re-run your application to gather statistics for use cases your are interested in - 
 you will simply see performance profile as you go.

Usage Guidelines
VisualStudio integration makes it pretty simple to start using MicroProfiler. Just follow these steps:

Right-click the project your want to profile in the solution tree and check 'Enable Profiling'. 
Please note, that this will force the environment to rebuild your project;
Build the project;
Run the project;
Profiler frontend will show-up automatically.
You may want to set the scope you wish to profile. 
In order to do this uncheck the 'Enable Profiling' menu item 
and add manually a pair of command line options to C/C++ compiler /GH /Gh for .cpp files of interest.

To remove the instrumentation and profiling support click 'Remove Profiling Support' in the context menu for the project.


.Visual Studio Extension for Lua
 https://visualstudiogallery.msdn.microsoft.com/46e33dfd-c2bd-4903-99b3-94ab0f6847e9

.需要实现一个框架，可设定多个object之间的依赖关系,当app退出时自动根据依赖关系来完结各object业务
 可归纳为消息通知,即制定好规则后在合适的时机发送消息
.object的树形结构和依赖绑定
-------------------------------------------------------------------------------
.采用gtest来做自动化测试
 gtest是Google's C++ test framework
 gtest在vs2015中test ok
 注意github中的gtest默认是采用静态库的，并且要求app也采用静态库，这点不方便，所以要把gtest改用动态库编译,app才能使用动态库
 gtest用法看自带文档就足够了,文档在G:\work\os\gtest\googletest-master\googletest\docs
/////////////////////////////////////////////////////////////////////////////
2016.03.20///////////////////////////////////////////////////////////////////
.可增加PostDelayRelease(shared_ptr<BaseHandler>& sp)
 由BaseLooper在下次循环中清除shared_ptr
 PostDispose()
//已增加BaseHandler::PostDispose(shared_ptr<BaseHandler> & sp);

/////////////////////////////////////////////////////////////////////////////
2016.03.19///////////////////////////////////////////////////////////////////
.设计客户端主动连接的管理
 client也可使用NetLooper和BaseTcpClient,但它没有BaseTcpServer
 可在BaseHandler上采用parent child机制解决此问题,有如下几种组合
 parent对child强/弱引用
 parent被child强/弱引用
AddStrongChild
AddWeakChild
virtual int SetStrongParent(shared_ptr<BaseHandler> obj);
virtual int SetWeakParent(weak_ptr<BaseHandler> obj);

changes:
.DemoHttpRequestHandler测试BaseTcpClient主动连接成功
 但生命周期管理仍然有待完善

.DemoHttpRequestHandler::OnMessage里有可能delete this
 需要想办法妥善解决此问题
//已采用PostDispose完美解决

changes:
.BaseHandler中集成了parent/child,可互相强弱引用
 在BaseTcpServer/BaseTcpClient中test ok

/////////////////////////////////////////////////////////////////////////////
2016.03.18///////////////////////////////////////////////////////////////////
.Looper的难点在于怎么优雅安全的退出，需要处理好边界问题

.BaseHandler存在的问题
 如果投递了消息，在looper还没处理消息之前就把BaseHandler删除了，则后面处理消息时会crash
 解决办法是投递消息时用shared_ptr做一个强引用
 缺点是会降低性能
 目前没有这样做，由开发者来保证BaseHandler有效

changes:
.GameTcpClient改名为GameTcpHandler

.测试发现MFC SetTimer性能非常好,每个timer占用一个User Handle
 发现MFC SetTimer只有9990个timer能真正生效
 user handle限制限制在10000个

.测试如下场景
 new 1w个object,push到map中
 每隔1秒依次调用object->OnTimer
 看cpu占用情况，比较全局轮询或timer消息性能
//经过_CONFIG_TEST_SINGLE_TIMER测试,
发现每秒轮询1百万个object->OnTimer,cpu为0
发现每秒轮询1千万个object->OnTimer,cpu<2%
这种测试占用cpu很少，真正应用时cpu高速cache失效重刷可能更影响性能
我们服务器最多1万个连接，所以采用这种整体轮询性能更高一些

/////////////////////////////////////////////////////////////////////////////
2016.03.17///////////////////////////////////////////////////////////////////
.在mt7628 gcc4.6.3中使用shared_ptr时，编译标志要加上 -std=gnu++0x
bear@ubuntu:/opt/buildroot-gcc463/usr/mipsel-buildroot-linux-uclibc/lib$ cd ../..
bear@ubuntu:/opt/buildroot-gcc463/usr$ find | grep shared_ptr
./mipsel-buildroot-linux-uclibc/include/c++/4.6.3/tr1/shared_ptr.h
./mipsel-buildroot-linux-uclibc/include/c++/4.6.3/bits/shared_ptr_base.h
./mipsel-buildroot-linux-uclibc/include/c++/4.6.3/bits/shared_ptr.h

.已测试,rt5350 gcc3.4.2不支持shared_ptr
cd /opt/buildroot-gcc342
find | grep shared_ptr找不到
好消息，经测试,gcc3.4.2可以使用boost中的shared_ptr
#include <boost/smart_ptr/shared_ptr.hpp>
boost::shared_ptr<EventSource> sp(new EventSource);
原因是boost中的shared_ptr全部采用.hpp实现，不需要编译boost
测试代码F:\asw\board\demo\testsigslot

.已测试,hisi3518 gcc4.4支持shared_ptr
测试编译使用boost时，hisi gcc需要编译boost源码
boost::lockfree::queue<int> mIoContextRecvFree;
目前只用到shared_ptr,所以只用std::shared_ptr就可以了
boost中的lockfree对嵌入式意义不大
pc中也可能意义不大

.gcc 3.4.2测试boost::signals2 ok,但没发现有什么用，直接用sigslot更方便些
.增加了Bundle类

bug fixed:
.修正了IoContext::PostSend()中的bug

数据传输框架设计要点
.要兼容epoll
 采用统一的接口支持windows和linux平台
.要兼容p2p
 不要局限于socket api,要考虑兼容p2p api接口,提供统一抽象数据传输层框架

主动连接/断开
Connect
Close

被动连接/断开i
OnConnect()
OnClose()

数据可读/可写通知
OnReceive()
OnSend()

主动读/写
Receive
Send

/////////////////////////////////////////////////////////////////////////////
2016.03.16///////////////////////////////////////////////////////////////////
.已对比webrtc中最新的sigslot.h,发现和cs中的sigslot.h基本无差异,所以可放心使用cs中的sigslot.h版本
 在单线程下使用sigslot是可以保证安全的
已在asw\board\demo\testsigslot中测试gcc3.4.2和gcc5.x都支持sigslot

.注意类的继承树中最多只能有一个enable_shared_from_this<T>,否则shared_from_this()无法正常工作
 在子类中使用时可用dynamic_pointer_cast来转换，比如
 shared_ptr<GameTcpClient> client=dynamic_pointer_cast<GameTcpClient>(shared_from_this());

changes:
.BaseTcpServer/BaseTcpClient/GameClientHandler从BaseHandler继承,这样能很方便的跨线程投递处理消息
//test ok

.在Test::TestPerformance()中比较了CCriticalSection比boost::lockfree的性能
 采用单线程，多线程(最多64个线程)来测试
 发现如下结论:
 CCriticalSection比boost::lockfree快5到10倍
 Release下比Debug下快很多倍
//看来lockfree用处感觉不是很大

想法:
.在逻辑没有依赖，压力较大的服务器中，可以采用多个线程来做LuaGameLooper,
 已连接上的client可以在根据需要在同一服务器进程的多个LuaGameLooper之间切换

.初步增加了iocp send机制

.简化BaseTcpClient

.增加了sigslot
//test ok

/////////////////////////////////////////////////////////////////////////////
2016.03.15///////////////////////////////////////////////////////////////////
想法:
.如果c++调用lua确实开销比较大，可以考虑把一部分包处理直接放在c++中来做
 主要是非常频繁调用，并且与其他业务逻辑无关的包,比如战斗中的位置移动包
.由NetLooper.GameTcpClient在解析到第一个包时创建GameClientHandler并投递给GameLooper
 此后GameClientHandler运行在GameLooper
 GameClientHandler在完结后由GameLooper投递返还给NetLooper.GameTcpClient

.NetLooper.GameTcpClient与GameLooper.GameClientHandler的绑定和解除
GameTcpClient需要通知GameClientHandler的事件包括
OnConnect
OnRecvPacket
OnClose

changes:
.下列做法已过时
		//BaseTcpClient::~BaseTcpClient()中采用BM_DETACH_CLIENT异步通知清除弱引用，可能引起一个问题:
		//BaseTcpClient已析构
		//在BaseTcpServer处理BM_DETACH_CLIENT之前，
		//OnAccept中恰好在已析构的BaseTcpClient地址上重建了新的BaseTcpClient
		//这样，在处理BM_DETACH_CLIENT时会删除合法的新BaseTcpClient
		//如此一来，在BaseTcpServer::Stop()中有可能漏掉强行断开新的BaseTcpClient,导致一直等待
		//发生此情况的几率很小，但理论上存在，所以要想办法避免
		//解决办法是创建BaseTcpClient时确保mClients中不存在此项
		//CreateBaseTcpClientSafe()就是起这个作用
//现在BaseTcpClient::~BaseTcpClient()同步清除弱引用,不会再引起此问题
//但前提是BaseTcpClient始终中NetLooper线程中析构
已采用ASSERT(IsMyselfThread());来确认这一点

/////////////////////////////////////////////////////////////////////////////
2016.03.14///////////////////////////////////////////////////////////////////
.tcmalloc:The fastest malloc we’ve seen; works particularly well with threads and STL. 
https://github.com/gperftools/gperftools
Just link in -ltcmalloc or -ltcmalloc_minimal to get the advantages of tcmalloc -- a replacement for malloc and new. 

但android jni里不能使用tcmalloc
http://goog-perftools.sourceforge.net/doc/tcmalloc.html
TCMalloc currently does not return any memory to the system.
Don't try to load TCMalloc into a running binary (e.g., using JNI in Java programs). 
The binary will have allocated some objects using the system malloc, and may try to pass them to TCMalloc for deallocation. 
TCMalloc will not be able to handle such objects.


.发现boost signals2一个奇怪的现象
 在vs2015和ubuntu下面编译运行如下代码，均发现HellWorld的析构函数被调用很多次
 //晕，不奇怪，忘记copy constructor了,基本上没主动用到过
class HelloWorld
{
public:
	HelloWorld()
	{
		printf("%s\n", __func__);
	}
	
	virtual ~HelloWorld()
	{
		printf("%s\n", __func__);
	}

	void operator()() const
	{
		printf("%s\n", __func__);
	}
};

int TestSignals2()
{
	//*
	boost::signals2::signal<void()> sig;

	HelloWorld hello;
	sig.connect(hello);

	sig();
	//*/

	return -1;
}
运行时输出:
bear@ubuntu:~/work/os/boost/testBoost/bin$ ./testBoost 
HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
~HelloWorld
operator()
~HelloWorld
~HelloWorld
bear@ubuntu:~/work/os/boost/testBoost/bin$ 
已测试，析构为virtual或非virtual都是如此

changes:
.增加了TestLuaDlg来测试c++调用lua的性能
 在调用lua中main空函数时,每秒能调用1kw次
 function main(value)
 end

 main中增加如下代码后,调用1百万次就占用1100ms左右
local gTable={}
function main(value)
	gTable["key" .. value] = value
	gTable["key" .. value] = value
end
如果用gTable[value]=value*value则速度很快，看起来是lua string太耗cpu了

.GameTcpClient中把解包也放在NetLooper中做

/////////////////////////////////////////////////////////////////////////////
2016.03.12///////////////////////////////////////////////////////////////////
在vs2015和gcc5.x中编译sigslot时都报错
warning C4346: 'const_iterator': dependent name is not a type
see reference to class template instantiation 'sigslot::has_slots<mt_policy>' being compiled
error C2061: syntax error: identifier 'const_iterator'
error C2238: unexpected token(s) preceding ';'
error C2504: 'has_slots': base class undefined
error C2143: syntax error: missing ',' before '<'
//发现sigslot最后更新日期是2002年，看来它使用的template技术已经过时了
采用boost:signal2可能是更好的选择

/////////////////////////////////////////////////////////////////////////////
2016.03.11///////////////////////////////////////////////////////////////////
changes:
.NetLooper SetTimer(1,1),即设定一个1ms的定时器，发现cpu占用在2%,这个不正常
//已解决,是GetQueuedCompletionStatus中cmsDelayNext计算有bug引起的
之前用提cmsDelayNext/=10;
当cmsDelayNext为1时,cmsDelayNext/=10;导致cmsDelayNext为0
这样GetQueuedCompletionStatus就被非常频繁的调用,从而占用cpu奇高
解决办法是当cmsDelayNext>0时,限制最终cmsDelayNext至少为1

.出现过GameLooper调用LOGF_I时 LogLooper已为null的情况
//原因:GameLooper依赖LogLooper,在GameLooper完全结束之前不能退出LogLooper,而目前并没有采取措施
目前由MainLooper管理GameLooper,在GameLooper结束之前MainLooper会一直运行
感觉可以把CLog集成到MainLooper,去掉LogLooper
//已去掉LogLooper

.客户端的多线程
 http://blog.csdn.net/baihacker/article/details/37061675
 这个文章讲了一些多线程问题，相对深入，但并没有demo代码来演示

.解决accept,send,write,close,disconnect
 这些事件要通知NetLooper
 NetLooper再通知GameLooper
 数据怎么跨线程传递，安全，高效


/////////////////////////////////////////////////////////////////////////////
2016.03.10///////////////////////////////////////////////////////////////////
changes:
.采用ConnectEx+iocp异步连接socket成功
 步骤:
 .创建socket时WSASocket要加WSA_FLAG_OVERLAPPED
 .CreateIoCompletionPort绑定iocp
 .bind绑定本地端口,INADDR_ANY和port 0即可(不绑定的话，会报10022错误)
 .调用ConnectEx,WSAGetLastError()会返回ERROR_IO_PENDING
 .通过GetQueuedCompletionStatus返回连接成功或失败，
  默认连接超时为20秒
  连接成功之后要调用setsockopt(sock, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0);

.应该尽量简化BaseLooper的子类析构函数，如有大量任务，请放在ExitInstance()中处理
 原因:主要是为了避免app退出时误报memory leak
 app可能在检测到looper weak_ptr失效时马上退出,但looper析构有可能还在进行中，就会误报memory leak
 如果looper析构执行很快，不太可能报memory leak
 一个更好的解决办法是传一个event handler给looper,looper在_WorkThreadCB最后面触发此事件
 app在退出之前等待此事件,可确保所有looper安全销毁
//已解决,增加了SetExitEvent接口，可完美解决此问题

.如何安全和优雅的退出NetLooper和GameLooper
 由于双方随时都有可能向对方发大量请求，所以要仔细规划退出时的场景
 这个场景和tcp断开连续比较相似,所以可仿照处理
 约定退出规则:
 .在NetLooper::OnBMQuit()中向GameLooper发BM_NET_LOOPER_FINISH
  表明NetLooper不再向GameLooper发主动包，但仍可响应GameLooper的请求包并可发回复包
 .GameLooper收到BM_GAME_LOOPER_FINISH之后,发BM_GAME_LOOPER_FINISH,并且不再向NetLooper发主动包
 .NetLooper收到BM_GAME_LOOPER_FINISH时，表明它已处理完所有可能的GameLooper主动包，并且GameLooper保证不再发主动包
  NetLooper发BM_NET_LOOPER_QUIT给GameLooper,这是最后一个包
 .GameLooper收到BM_NET_LOOPER_QUIT后可安全释放交叉强引用,从而析构NetLooper和GameLooper
 说明:
 .不能在NetLooper::OnBMQuit()中直接发BM_NET_LOOPER_QUIT
  原因:在GamLooper没发BM_GAME_LOOPER_FINISH之前,它有可能一直向NetLooper投递消息
  所以当执行到NetLooper::OnBMQuit()时，NetLooper的消息队列中可能还有大量GameLooper消息需要处理
//已加，验证测试通过

.TcpClient和ClientHandler绑定，协助工作
 TcpClient在网络iocp线程中
 ClientHandler在业务iocp线程中
 需要跨线程协作
.ClientHandler和LuaHandler绑定

/////////////////////////////////////////////////////////////////////////////
2016.03.08///////////////////////////////////////////////////////////////////
.测试cpu占用，每秒100Mbps网络流量
{
	int len = 1024 * 1024 * 10;
	static LPBYTE p = new BYTE[len];
	int bytesPerTime = 1;
	for (LPBYTE src = p; src < p + len - bytesPerTime; src += bytesPerTime)
	{
		memset(src, 0, bytesPerTime);
		//memset(src, 1, bytesPerTime);
	}
}
cpu占用约为0%

.NetLooper和GameLooper
NetLooper负责网络通讯，一般来说,一个进程有且只有一个NetLooper
GameLooper负责构建lua脚本运行环境,一个进程可以有多个GameLooper,这里的Game是指游戏服务端

.在MainLooper::CanQuitLooperNow()中采用shared_ptr<LogLooper> svr = mLogLooper.lock();
	这种方式是有问题的
	在LogLooper::~LogLooper()中加入Sleep来模拟析构非常耗时的场景
	在Sleep时,MainLooper退出导致app退出,此时会报memory leak,是LogLooper没有delete完全引起的
	这个靠shared_ptr无法解决,只能要求在析构函数尽快执行完成
//已在2016.03.10采用event完美解决

拓展:
由于NetLooper中各TcpClient是完全独立的，互不依赖，也没有业务来往
所以TcpServer实际上可以把client分派到多个并行的NetLooper中运行，不影响效果，并发性能更好
只有第一个NetLooper内置TcpServer,其他辅助NetLoop只用于TcpClient

app高性能的技巧:
消除依赖，尽量并行
缩小范围,化整为零,也是增加并行
比如大厅场景和游戏室场景

想法:
.发现公司游戏服务器GLogin,GCenter,GMatcher,GBattler,GServer的MFC代码基本相同
 所以可以只采用一个MFC工程，生成一个app,通过传入参数来执行不同的lua脚本即可

/////////////////////////////////////////////////////////////////////////////
2016.03.07///////////////////////////////////////////////////////////////////
https://msdn.microsoft.com/zh-sg/library/windows/desktop/aa364986(v=vs.85).aspx
此文提到
If a call to GetQueuedCompletionStatus fails because the completion port handle associated with it is closed while the call is outstanding, 
the function returns FALSE, *lpOverlapped will be NULL, and GetLastError will return ERROR_ABANDONED_WAIT_0.
Windows Server 2003 and Windows XP:  Closing the completion port handle while a call is outstanding will not result in the previously stated behavior.
The function will continue to wait until an entry is removed from the port or until a time-out occurs, if specified as a value other than INFINITE.
通过在winxp和win7上测试，发现确实如此
测试流程:创建iocp handle和thread调用GetQueuedCompletionStatus(...,INFINITE),然后马上close iocp handle

win7上面GetQueuedCompletionStatus能马上返回FALSE,GetLastError返回ERROR_ABANDONED_WAIT_0

而winxp上面GetQueuedCompletionStatus一直阻塞,解决办法是在close iocp handle之前PostQueuedCompletionStatus一下,
GetQueuedCompletionStatus至少成功一次，再调用GetQueuedCompletionStatus时会返回GetLastError为6,表示handle无效

.经测试已PostAccept时，关掉mListenSock时,GetQueuedCompletionStatus能返回相应次数的GetLastError 995
调查BaseTcpServer::Stop()//发现一个奇怪的现象, 采用AcceptEx投递之后，在关闭sListen时, AcceptEx事件没能返回
//已查清，有返回，是之前只考虑了GetQueuedCompletionStatus返回TRUE的情况，而此种情况是返回FALSE


.https://msdn.microsoft.com/en-us/library/ms738551(v=vs.85).aspx
High-performance Windows Sockets Applications
Windows is capable of servicing over 200,000 simultaneous TCP connections.
In a test conducted by SPECWeb96, Internet Information Server on Windows serviced over 25,000 HTTP requests per second.
Windows set a transmission record of over 750Mbps on a transcontinental gigabit network consisting of 10 hops.

https://msdn.microsoft.com/en-us/library/ms740550(v=vs.85).aspx
Do not turn off send buffering unless you have considered the impact in all network environments. 
One exception: streaming data using overlapped I/O should set the send buffer to zero.
此文提到:采用overlapped的发包应该禁用send buffer


.理清ref count和looper主循环的关系
某一时刻是否应该和是否能退出looper主循环，与此looper的ref count无关
而是与是否调用了looper.PostQuitMessage()有关
另外，为了能安全的结束winsock中的outstanding业务，所以需要确保所有outstanding业务已完结

changes:
.基本上完美解决了Looper+BaseTcpServer+BaseTcpClient生命周期管理
 细节请参见BaseTcpServer类的说明
.增加了BaseTcpServer::CreateBaseTcpClientSafe(),可保证不会错用client

.sendMessage和postMessage的临界点问题
跨线程调用另一looper线程时，可能出现竞争,即looper主循环已部分退出，随后又加新消息到消息队列中,会造成消息没被处理
//已在looper析构中检测并ASSERT,这个由app调用者来保证

/////////////////////////////////////////////////////////////////////////////
2016.03.05///////////////////////////////////////////////////////////////////
想法:
.socket传输和lua可采用单独的线程
 锁的粒度要小,最好是不要加锁，而是采用loop message来通讯
 SocketClient收到一个包后postMessage发给LauLooper.LuaClient(是的，为提高性能，甚至不采用sendMessage，而只是用postMessage来投递)
 SocketClient和LuaClient的绑定和解除也要用Looper.postMessage来实现

.app内置http server,采用tree node提供各组件的运行状态

/////////////////////////////////////////////////////////////////////////////
2016.03.04///////////////////////////////////////////////////////////////////
.在looper框架中集成异步tcp server,client
 解决accept,send,write,close,disconnect

.server是否要维护所有connection的列表
 为了能主动断开所有连接，需要维护所有的client,可采用std::map来做
.connection的生命周期控制
 有两种做法
 1.server完全控制,当连接断开时马上delete client
 2.采用ref count,server只是引用一次,当连接断开了server取消对client的引用

 .何时删除BaseTcpClient

IOCP框架的困境
iocp WSASend/WSARecv要求提交buffer给iocp api,windows底层会在适当的时候采用此buffer来发送或接收数据
app在GetQueuedCompletionStatus返回执行结果之前不能删除此buffer,否则windows底层可能访问非法内存
这说明app的iocp工作线程应该确保所有已提交的WSASend/WSARecv都收到对应的GetQueuedCompletionStatus结果之后才能退出线程
如果没收到就退出iocp工作线程,要么可能访问异常，要么干脆不删除未决的buffer

https://msdn.microsoft.com/en-us/library/ms737582(VS.85).aspx
windows closesocket文档中提到
The closesocket function closes a socket.
Any pending overlapped send and receive operations ( WSASend/ WSASendTo/ WSARecv/ WSARecvFrom with an overlapped socket) 
issued by any thread in this process are also canceled. Any event, completion routine, or completion port action specified for 
these overlapped operations is performed. The pending overlapped operations fail with the error status WSA_OPERATION_ABORTED.

An application should not assume that any outstanding I/O operations on a socket will all be guaranteed to completed when closesocket returns.
 The closesocket function will initiate cancellation on the outstanding I/O operations, but that does not mean that an application 
 will receive I/O completion for these I/O operations by the time the closesocket function returns. 
 Thus, an application should not cleanup any resources (WSAOVERLAPPED structures, for example) 
 referenced by the outstanding I/O requests until the I/O requests are indeed completed.

WSACleanup文档中提到
When WSACleanup is called, any pending blocking or asynchronous Windows Sockets calls issued by any thread in this process are 
canceled without posting any notification messages or without signaling any event objects. 
Any pending overlapped send or receive operations (WSASend, WSASendTo, WSARecv, or WSARecvFrom with an overlapped socket, for example) 
issued by any thread in this process are also canceled without setting the event object or invoking the completion routine, if one was specified.
 In this case, the pending overlapped operations fail with the error status WSA_OPERATION_ABORTED.

可以看出IOCP框架确实存在这些困境
microsoft提供的demo代码中，在app结束之前都调用了WSACleanup();
WSACleanup()能确保完全取消当前进程中所有线程提交的未决业务
但问题在于WSACleanup是积累的，每个WSAStartup要对应WSACleanup,并且只针对进程而非单个线程
所以没法用WSACleanup来解决此困境

由上述分析可知，对每个未决iocp业务做ref count是必要的,并且在ref count>0时要继续调用GetQueuedCompletionStatus
只有所有业务都通过GetQueuedCompletionStatus完结后,app才能安全的清除WSAOVERLAPPED和buffer等资源

TcpServer要感知TcpClient完结
TcpServer对TcpClient rc加1,当TcpClient每提交一个未决业务时就增加一个rc,业务完结时dec 1,当回到仅有一个rc时通知TcpServer回收TcpClient

Looper要感知所管理的TcpServer完结
Looper对每个TcpServer rc加1,每个TcpServer完结时 rc减1,当所有TcpServer都空闲时CanQuitLooperNow()返回true

/////////////////////////////////////////////////////////////////////////////
2016.03.03///////////////////////////////////////////////////////////////////
EventLoop is an object oriented event loop for linux using c++.
https://github.com/dccmx/EventLoop
F:\bear\asw\board\demo\EventLoop
测试可运行，采用epoll实现，但功能比较简单。由于采用一个全局loop对象，导致没有扩展性

/////////////////////////////////////////////////////////////////////////////
2016.02.23///////////////////////////////////////////////////////////////////
android的消息处理机制（图+源码分析）——Looper,Handler,Message
http://www.cnblogs.com/codingmyworld/archive/2011/09/14/2174255.html

/////////////////////////////////////////////////////////////////////////////
2016.02.17///////////////////////////////////////////////////////////////////
今天研究了wxWidgets,发现比较好用，在vs中能直接编译运行,支持linux,windows和osx

/////////////////////////////////////////////////////////////////////////////
2016.01.28///////////////////////////////////////////////////////////////////
.增加了抽象类BaseDataEndPoint,有待在windows下iocp实现

/////////////////////////////////////////////////////////////////////////////
2016.01.27///////////////////////////////////////////////////////////////////
.统一epoll和iocp的处理框架
 epoll是通知可读或可写,client要主动调用读写api才能读写数据
 iocp是完成读或写后才通知
 为统一框架，需要加一个中间层
 发现在iocp基础上模拟epoll简单些

.bug fixed:
今天遇到了c++多继承引起的问题
BaseTcpServer_Linux中侦听accept事件时采用
evt.data.ptr = this;
结果发现基类顺序要为class BaseTcpServer_Linux:public EpollProxy,public BaseHandler
如果为class BaseTcpServer_Linux:public BaseHandler, public EpollProxy,则收不到accept事件
后面找到原因,要改为evt.data.ptr = (EpollProxy*)this;这样就和基类顺序无关了
iocp代码中也有类似问题，已改正

---------------------------------------------------------------------
netstat -an -p tcp | grep 8080

.valgrind用法
注意ubuntu自带的valgrind版本太旧，不支持调试64bit app
需要从官网下载valgrind源码自行make,make install
sudo mv /usr/bin/valgrind /usr/bin/valgrind.old
sudo ln -s /usr/local/bin/valgrind /usr/bin/valgrind
然后采用/usr/local/bin/valgrind
valgrind -q --leak-check=full  --tool=memcheck ./ds
valgrind -q --leak-check=full ./ds
valgrind -q --tool=memcheck ./ds
默认tool是memcheck,所以可不写--tool=memcheck
要加上--leak-check=full,否则有可能检测不出int *p=new int;这样的memory leak

.决定linux下memory leak用ValGrind
valgrind测试效果:
故意写如下代码
int main()
{
	int *p = new int;
	return 0;
}

bear@ubuntu:/mnt/jjy/bin/debug$ /usr/local/bin/valgrind -q --leak-check=full ./ds
==16891== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2
==16891==    at 0x4C27078: operator new(unsigned long) (vg_replace_malloc.c:333)
==16891==    by 0x433BBC: Main::main() (main.cpp:28)
==16891==    by 0x433B74: main (main.cpp:15)
==16891== 
可看到valgrind能准确定位代码行


.查看当前侦听的tcp端口及app
 sudo netstat -tlnp
bear@ubuntu:/proc/1661$ sudo netstat -tlnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1009/sshd       
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1204/cupsd      
tcp6       0      0 :::445                  :::*                    LISTEN      746/smbd        
tcp6       0      0 :::139                  :::*                    LISTEN      746/smbd        
tcp6       0      0 :::22                   :::*                    LISTEN      1009/sshd       
tcp6       0      0 ::1:631                 :::*                    LISTEN      1204/cupsd     

/////////////////////////////////////////////////////////////////////////////
2016.01.26///////////////////////////////////////////////////////////////////
ubuntu更新time
sudo ntpdate time.nist.gov

changes:
.集成了BaseLooper框架

.集成http框架，不要强制任何依赖，所有必须的接口都做成app可配置的
 这样方便多个app调用
.集成http时要统一iocp和epoll

.BaseLooper增加了StartWithinCurrentThread
 用来在windows/linux主线程中运行looper

/////////////////////////////////////////////////////////////////////////////
2016.01.26///////////////////////////////////////////////////////////////////
.printenv打印当前所有的环境变量
.cmake中引用环境变量$ENV{变量名}
比如home目录
$ENV{HOME}

changes:
.BaseLoop_Windows::sendMessage中采用stack来代替heap looper
 可避免频繁new delete

.发现ubuntu下gcc5.3.0默认编译为64bit app
 可用file ./t查看t的32/64bit信息
比如
 bear@ubuntu:/mnt/board/demo/testLoop/bin$ file ./t
./t: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, not stripped

.已测试,AndroidStudio支持编译编译格式为utf8 .cpp文件为jni.so

.app中调用脚本成功
 t.sh内容为
#!/bin/bash
echo "hello,linux shell script!"
注意分行符为0x0a,不能为0x0d,0x0a
c++代码
ShellTool::System("sh ./t.sh"); return 0;
运行可看到
bear@ubuntu:/mnt/board/demo/testLoop/bin$ ./t
hello,linux shell script!
bear@ubuntu:/mnt/board/demo/testLoop/bin$ 

.增加了BaseLooper,它封装不同平台的looper基类
 用户自定义looper应该从BaseLooper或其子类继承

.可考虑条件编译无锁,无锁需要boost,有时不太方便
 一般app采用CCriticalSection时的性能已经足够了，只有游戏服务器需要无锁来提高性能

.testLoop工程的预定目标初步完成，有待后续实际应用中完善

.BaseLooper_Linux::~BaseLooper_Linux增加了
	SockTool::CLOSE_SOCKET(mSockPairSend);
	SockTool::CLOSE_SOCKET(mSockPairReceive);

/////////////////////////////////////////////////////////////////////////////
2016.01.25///////////////////////////////////////////////////////////////////
.cmake显示编译的命令行
 make VERBOSE=1

changes:
.linux下面epoll timer test ok
 发现linux timer比windows下的要精确一些

.epoll timer,handler test ok
.epoll event绑定c++ handler test ok
/////////////////////////////////////////////////////////////////////////////
2016.01.22///////////////////////////////////////////////////////////////////
changes:
.完善了BaseHandler
.区分looper thread message和BaseHandler message
.BaseHander增加了timer


.looper启动时传参数
.BaseMessage传自定义参数
.抽象出BaseLooper_Interface虚基类,给每个平台实现一个BaseLooper基类,采用条件编译来定义BaseLooper
#ifdef _MSC_VER
	#define BaseLooper BaseLooper_Windows		//采用iocp
#elif defined __APPLE__
	#define BaseLooper BaseLooper_Ios			//采用kqueue
#elif defined __ANDROID__
	#define BaseLooper BaseLooper_Android		//采用epoll
#elif defined __PC_LINUX__
	#define BaseLooper BaseLooper_Linux			//采用epoll,可与Android版合并
#endif
更好的办法是BaseLooper:public BaseLooper_Windows/BaseLooper_Ios...
在使用时直接从BaseLooper继承

.采用epoll实现目前iocp的功能

/////////////////////////////////////////////////////////////////////////////
2016.01.21///////////////////////////////////////////////////////////////////
android的消息处理机制（图+源码分析）——Looper,Handler,Message
http://www.cnblogs.com/codingmyworld/archive/2011/09/14/2174255.html
这是个很好的文章
我们的BaseLoop可参考android Looper框架

shared_ptr使用注意事项
对于同一raw pointer,只能用一个shared_ptr对象实例来封装它,可通过此shared_ptr对象实例传给其他shared_ptr对象
但不能再次采用shared_ptr对象实例来直接封装此raw pointer,否则相当两个shared_ptr各自独立的对raw pointer做引用引数，肯定会出错
如确有需要，必须采用enable_shared_from_this
下面这个网页讲了同样的问题
http://www.cnblogs.com/wpcockroach/p/3611747.html

changes:
.发现一个奇怪的现象,采用AcceptEx投递之后，在关闭sListen甚至投递的socket之后,AcceptEx事件没能返回
 GetQueuedCompletionStatus收不到任何事件

.注意:
 使用shared_ptr时，切记要使用shared_from_this(),否则很容易造成多个shared_ptr管理同一个raw pointer
 此种bug很难找出
 尽量避免使用this指针

/////////////////////////////////////////////////////////////////////////////
2016.01.20///////////////////////////////////////////////////////////////////
.需要找到合适的办法来让shared_ptr管理looper
 looper线程有个特点:当ref count归0后要做一些清理操作才能退出线程
 而shared_ptr是在ref count归0后马上delete this
//可能的办法
 内置一个shared_ptr mSP指向自身，当收到BM_QUIT事件后每次循环都检查shared_ptr是否为unique
 在unique时做清查，然后置mSP=NULL即可
//已加，test ok,使用效果很好

/////////////////////////////////////////////////////////////////////////////
2016.01.18///////////////////////////////////////////////////////////////////
http://blog.csdn.net/henan_lujun/article/details/8984543
C++没有垃圾收集，资源管理需要自己来做。
智能指针可以部分解决资源管理的工作，但是不是万能的。
使用智能指针的时候，每个shared_ptr对象都应该有一个名字；也就是避免在一个表达式内做多个资源的初始化；
避免shared_ptr的交叉引用；使用weak_ptr打破交叉；
使用enable_shared_from_this机制来把this从类内部传递出来；
资源管理保持统一风格，要么使用智能指针，要么就全部自己管理裸指针

.在windows下编译android版boost
http://blog.csdn.net/ly131420/article/details/46648125
//采用android-ndk-r9d和android-ndk-r10d都能成功编译boost_1_55_0
生成的.a在D:\tools\android\android-ndk-r9d-windows-x86_64\android-ndk-r9d\sources\boost_1_55_0\android\lib
生成的.a文件都以-gcc-mt-s-1_55.a结尾，比如libboost_log-gcc-mt-s-1_55.a,原因未知
编译生成的.a中没有pthread库

要生成thread库时需要加 threadapi=pthread
b2.exe --without-python --without-mpi --without-serialization toolset=gcc-android4.8 link=static runtime-link=static target-os=linux --stagedir=android threadapi=pthread
//android-ndk-r9d和android-ndk-r10d编译时都报cc1plus.exe已停止工作，没能成功编译
android-ndk-r8e可成功编译出libboost_thread_pthread-gcc-mt-s-1_55.a

/////////////////////////////////////////////////////////////////////////////
2016.01.15///////////////////////////////////////////////////////////////////
.采用shared_ptr和weak_ptr来替代手工ref count

/////////////////////////////////////////////////////////////////////////////
2016.01.14///////////////////////////////////////////////////////////////////
DemoServer设计
初步定为3个线程，均绑定cpu
NetLooper
DBLooper
LogicLooper

工作流程
NetLooper侦听socket,创建ClientProxy,负责数据收发线程,收包后无锁投递给LogicLooper

changes:
.NetLooper和LogicLooper双iocp test ok

LogicLooper的任务比NetLooper重，所以能转交给NetLooper的事务要尽量由NetLooper来做

.boost::lockfree::queue<tagLoopMessageInternal> mMessageQueue;
 mMessageQueue要设定初始free个数，否则Debug下boost会ASSERT,但不影响功能

经压力测试,采用SetThreadAffinityMask绑定NetLooper和LogicLooper之后，速度比没绑定要快20%左右
每秒能处理250w个PostQueuedCompletionStatus事件
5v5,每个玩家每秒20个主动包，收9*20个包,即每秒200个包,理想情况下单台服务器可以支持1万个玩家


http://bbs.csdn.net/topics/320110973

changes:
.现在mCS只用来同步mPriorityQueue
 可把SetTimer和KillTimer改用sendMessage来实现，这样就可去掉mCS了,可做到完全不需要同步锁
//已改，在BaseLoop_Impl_Iocp中test ok

http://blog.csdn.net/liuyukuan/article/details/5471534
Lua For Windows 环境配置及使sciTE支持中文


/////////////////////////////////////////////////////////////////////////////
2016.01.12///////////////////////////////////////////////////////////////////
性能优化细节
.采用流水线管道
 socket input和output实际上是相当独立的
游戏业务数据包特性分析
 游戏中登录，普通业务逻辑的数据量很少，最多是和服务器直接交换数据
 数据包大头是游戏过程中的数据转发,比如5v5时，每个玩家的数据要转给其他9个玩家
 如果转发数据给玩家时要求对玩家进行同步加锁,即使采用多核cpu,也会频繁的出现多个线程争锁同一个玩家，造成不必要的等待和线程切换
 这样性能肯定上不去,症状是cpu很空闲，但业务数据包流量上不去
 解决办法:转发数据给玩家时无锁

 另外，收发数据和业务逻辑也采用单独的线程来做，充分发挥多核cpu的性能
 为优化性能，可绑定线程和cpu核心,比如:
 cpu0只管iocp收发数据,然后投递给数据线程cpu1处理
 cpu1只管业务逻辑，发数据是转给cpu0来处理
 通过绑定线程和cpu核，可比较容易的看到cpu主要耗在哪个环节

绑定cpu和iocp线程
.可采用多个iocp handle,比如收发采用mSocketIocp,业务线程采用mLogicIocp
 采用单独的thread来处理mXXXIocp，thread绑定指定的cpu核即可
 数据库操作采用mDBIocp和thread


下面这个帖子有人的想法和我一样:
http://bbs.csdn.net/topics/310230780
 IO线程除了收发不要处理业务逻辑，业务逻辑放到其他线程中去，降低IO线程的负担
比较简单的解决办法是使用双完成端口，一个处理IO，另一个处理业务
IO线程与业务线程之间使用PostQueuedCompleteStatus传递数据

.采用上面的想法，写一个DemoServer和DemoClient来实测
 DemoServer采用多iocp,多个专用线程
 DemoClient模拟多个npc,平均每秒发20个数据包，由DemoServer转发，测试性能

-------------------------------------------------------------------------
changes:
.BaseRefCountObject增加了不允许复制

/////////////////////////////////////////////////////////////////////////////
2016.01.11///////////////////////////////////////////////////////////////////
服务器性能优化关键点
按优先级别从高到低
.业务逻辑规划优化，尽量无状态流水线作业
.避免等待和阻塞
.避免频繁的内存分配和线程切换
.充分利用cpu多核
.采用无锁数据结构(可引入boost)
.尽量避免内存copy

-------------------------------------------
如果cpu不是很忙，但业务性能上不去，可能就是阻塞或线程切换太多引起的
-------------------------------------------

changes:
.BaseLoop_Impl增加了boost lockfree,可采用_CONFIG_LOCK_FREE来切换
 经测试发现lockfree和CCriticalSection的性能差异不明显

 .关于资源生命周期管理的想法
  采用ref count
  每个iocp线程内置一个refCount,在创建时inc+1,在想销毁时dec-1
  如果在iocp内部启动了TcpServer,则TcpServer对iocp.refCount inc+1
  TcpServer内部再维护一个refCount,当内部创建活动的TcpClient时,TcpServer.refCount+1,但此时不影响iocp.refCount
  当TcpServer.refCount变小为0时再通知iocp.refCount dec-1
  即采用分层管理refCount
  树形结构如下:
  Iocp.RefCount
	TcpServer1.RefCount
		TcpClient1.RefCount
		TcpClient2.RefCount
		...
	TcpServer2.RefCount
		TcpClient1.RefCount
 每一级有自己的refCount，用来表示自身的未决业务个数
 当自身refCount为0时可清除自身，并且通知上一级,上一级RefCount可-1,
 如果此时上一级RefCount仍然>0则不需要通知上上级
 如果此时上一级RefCount为0,则需要通知上上级,依此递归
 //已加

.BaseLoop::Stop()可以要去掉,改用PostQuitMessage
 原因:可参见java Thread类的设计
 为安全退出线程,线程必须做一些清理工作,这些工作可能比较耗时，所以同步的Stop()肯定要求等待
 这违背了异步非阻塞的设计理念
 如果上层确实需要感知BaseLoop.Thread安全退出，可以在BaseLoop子类的ThreadEntry()中发消息给上层

/////////////////////////////////////////////////////////////////////////////
2016.01.09///////////////////////////////////////////////////////////////////
changes:
.增加了BaseLoop_Impl_Iocp,采用GetQueuedCompletionStatus+PostQueuedCompletionStatus
 test timer ok
测试环境(家里台式机,AMD x64 4核cpu)
Release版BaseLoop_Impl_Iocp
 压力测试100万次sendMessage,平均耗时8秒左右,每秒约12.5万次
 压力测试100万次postMessage,平均耗时2秒左右

Release版CEvent+WaitForSingleObject
 压力测试100万次sendMessage,平均耗时8秒左右
 压力测试100万次postMessage,平均耗时2秒左右

看起来两者性能差不多,但sendMessage比公司i7的性能要好,这个有点奇怪
//原因可能如下
在家里台式机设定
只允许在第一个cpu上运行BaseLoop
	HANDLE hThread = OpenThread(THREAD_SET_INFORMATION | THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	DWORD_PTR value=SetThreadAffinityMask(hThread, 0x0001);
	sendMessage 100万次,测试多次均只需要4秒左右,测试时第一个cpu一直是占用100%

只允许在第一个和第二个cpu上运行BaseLoop
	HANDLE hThread = OpenThread(THREAD_SET_INFORMATION | THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	DWORD_PTR value=SetThreadAffinityMask(hThread, 0x0003);
	sendMessage 100万次,测试多次均需要8秒左右
可见公司8核i7 sendMessage的性能比家里4核的性能低，是因为cpu核心数太多导致线程调度频繁引起的!

.集成iocp异步socket框架
 BaseTcpClient可以收到数据了，有待设计send框架
 发送最好采用两个buffer,一个是目前正在发送的buf，另一个是可填充新发送数据的buf

/////////////////////////////////////////////////////////////////////////////
2016.01.08///////////////////////////////////////////////////////////////////
测试环境(公司台式机,i7 8核cpu)
Release版
发送100万条消息,消息处理为空
BaseLoop::sendMessage耗时5秒到20秒左右(一般是20秒左右),平均每秒能发送约5万次
BaseLoop::postMessage耗时500ms以内,平均每秒能发送约200万次

win32::SendMessage耗时5.5到20秒左右(一般为20秒左右),平均每秒能发送约5万次以上
win32::PostMessage耗时600ms到1.5秒左右(一般为1000ms左右),平均每秒能发送约150万次

考虑到BaseLoop目前的框架很简单，而win32消息框架是完整功能的，所以可看出win32的效率真是高

ShellTool::GetTickCount64(),运行100万次，耗时一般为0ms

.在win32主线程中调用BaseLoop::sendMessage,在处理此message时向主线程调用SendMessage会死锁
 原因是win32 UI线程阻塞在BaseLoop::sendMessage中,BaseLoop::getMessage没有分派win32 message
//以后如有需要再解决，现可用PostMessage

.可采用GetQueuedCompletionStatus来替换WaitForSingleObject,这样可集成socket事件
 如果GetQueuedCompletionStatus不能兼容CEvent,可采用socketpair+PostQueuedCompletionStatus来模拟实现
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);

.timer
//SetTimer,KillTimer初步测试ok,精度不够，后面再改进

.集成socket事件
 Windows:GetQueuedCompletionStatus + PostQueuedCompletionStatus
 linux:epoll_wait
 ios:kqueue
 iocp,epoll和kqueue的api接口很类似，都有timeout参数

 iocp AcceptEx完美集成iocp demo
 http://blog.csdn.net/VisualEleven/article/details/6088590

 iocp WSAAccept demo,WSAAccept缺点是阻塞，会占用一个thread,所以应该优先使用AcceptEx
 http://blog.csdn.net/VisualEleven/article/details/6041893

/////////////////////////////////////////////////////////////////////////////
2016.01.07///////////////////////////////////////////////////////////////////
.BaseLoop测试sendMessage和postMessage成功
 两个BaseLoop可对发sendMessage和postMessage,能按时序处理，不会阻塞死锁
 BaseLoop在调用sendMessage时能响应其他线程发送的消息

.增加timer
//一次性timer test ok,有待增加多次timer功能

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
XiongWanPing 2016.01.06
testLoop用来测试消息循环,旨在研究同时支持Windows,Linux,Android,ios的线程+消息机制
