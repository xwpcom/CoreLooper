#pragma once
#include <iostream>
#include <fstream>
#include <chrono>
#include <string>
#include <algorithm>

using namespace std;

#define TRIM(s, chars) \
do{ \
    string map(0xFF, '\0'); \
    for (auto &ch : chars) { \
        map[(unsigned char &)ch] = '\1'; \
    } \
    while( s.size() && map.at((unsigned char &)s.back())) s.pop_back(); \
    while( s.size() && map.at((unsigned char &)s.front())) s.erase(0,1); \
}while(0);

//Remove leading and trailing spaces, carriage returns, and tabs
std::string& trim(std::string& s, const string& chars = " \r\n\t") {
	TRIM(s, chars);
	return s;
}

std::string trim(std::string&& s, const string& chars = " \r\n\t") {
	TRIM(s, chars);
	return std::move(s);
}


template<typename key, typename variant>
class IniBase : public map<key, variant> {
public:
	void parse(const string& text) {
		// reset, split lines and parse
		vector<string> lines = tokenize(text, "\n");
		string symbol, tag;
		for (auto& line : lines) {
			// trim blanks
			line = trim(line);
			// split line into tokens and parse tokens
			if (line.empty() || line.front() == ';' || line.front() == '#') {
				continue;
			}
			if (line.size() >= 3 && line.front() == '[' && line.back() == ']') {
				tag = trim(line.substr(1, line.size() - 2));
			}
			else {
				auto at = line.find('=');
				symbol = trim(tag + "." + line.substr(0, at));
				(*this)[symbol] = (at == string::npos ? string() : trim(line.substr(at + 1)));
			}
		}
	}

	int parseFile(const string& fileName) {
		ifstream in(fileName, ios::in | ios::binary | ios::ate);
		if (!in.good()) {
			//throw invalid_argument("Invalid ini file: " + fileName);
			return -1;
		}
		auto size = in.tellg();
		in.seekg(0, ios::beg);
		string buf;
		buf.resize((size_type)size);
		in.read((char*)buf.data(), size);
		parse(buf);

		return 0;
	}

	string dump(const string& header = "; auto-generated by IniConfiger class {",
				const string& footer = "; } ---") const {
		string front(header + (header.empty() ? "" : "\r\n")), output, tag;
		vector<string> kv;
		for (auto& pr : *this) {
			auto pos = pr.first.find('.');
			if (pos == string::npos) {
				kv = { "", pr.first };
			}
			else {
				kv = { pr.first.substr(0, pos), pr.first.substr(pos + 1) };
			}
			if (kv[0].empty()) {
				front += kv[1] + "=" + pr.second + "\r\n";
				continue;
			}
			if (tag != kv[0]) {
				output += "\r\n[" + (tag = kv[0]) + "]\r\n";
			}
			output += kv[1] + "=" + pr.second + "\r\n";
		}
		return front + output + "\r\n" + footer + (footer.empty() ? "" : "\r\n");
	}

	void dumpFile(const string& fileName = exePath() + ".ini") {
		ofstream out(fileName, ios::out | ios::binary | ios::trunc);
		auto dmp = dump();
		out.write(dmp.data(), dmp.size());
	}

	static IniBase& Instance();

private:
	vector<string> tokenize(const string& self, const string& chars) const {
		vector<string> tokens(1);
		string map(256, '\0');
		for (char ch : chars) {
			map[(uint8_t)ch] = '\1';
		}
		for (char ch : self) {
			if (!map.at((uint8_t)ch)) {
				tokens.back().push_back(ch);
			}
			else if (tokens.back().size()) {
				tokens.push_back(string());
			}
		}
		while (tokens.size() && tokens.back().empty()) {
			tokens.pop_back();
		}
		return tokens;
	}
};

//  handy variant class as key/values
struct variant : public string {
	template<typename T>
	variant(const T& t) :
		string(to_string(t)) {
	}

	template<size_t N>
	variant(const char(&s)[N]) :
		string(s, N) {
	}

	variant(const char* cstr) :
		string(cstr) {
	}

	variant(const string& other = string()) :
		string(other) {
	}

	template <typename T>
	operator T() const {
		return as<T>();
	}

	template<typename T>
	bool operator==(const T& t) const {
		return 0 == this->compare(variant(t));
	}

	bool operator==(const char* t) const {
		return this->compare(t) == 0;
	}

	template <typename T>
	typename enable_if<!is_class<T>::value, T>::type as() const {
		return as_default<T>();
	}

	template <typename T>
	typename enable_if<is_class<T>::value, T>::type as() const {
		return T((const string&)*this);
	}

private:
	template <typename T>
	T as_default() const {
		T t;
		stringstream ss;
		return ss << *this && ss >> t ? t : T();
	}
};

template <>
bool variant::as<bool>() const;

template <>
uint8_t variant::as<uint8_t>() const;

string& strToLower(string& str) {
	transform(str.begin(), str.end(), str.begin(), tolower);
	return str;
}

string& strToUpper(string& str) {
	transform(str.begin(), str.end(), str.begin(), toupper);
	return str;
}

string strToLower(string&& str) {
	transform(str.begin(), str.end(), str.begin(), tolower);
	return move(str);
}

string strToUpper(string&& str) {
	transform(str.begin(), str.end(), str.begin(), toupper);
	return move(str);
}

template <>
bool variant::as<bool>() const {
	if (empty() || isdigit(front())) {
		return as_default<bool>();
	}
	if (strToLower(string(*this)) == "true") {
		return true;
	}
	if (strToLower(string(*this)) == "false") {
		return false;
	}

	return as_default<bool>();
}

template<>
uint8_t variant::as<uint8_t>() const {
	return 0xFF & as_default<int>();
}

using IniConfiger = IniBase<string, variant>;

template<>
IniBase<string, variant>& IniBase<string, variant>::Instance() {
	static IniBase<string, variant> instance;
	return instance;
}
