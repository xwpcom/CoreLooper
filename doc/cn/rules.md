# c++11代码原则
## 编程指引
在很多开源项目中经常能发现一些亮点，同时也能发现一些不好的用法，有些在CoreLooper中提出了相应的解决办法。  
本文对事不对人，纯粹讨论技术。  

- 手工调用new和delete  
**c++11请尽量使用make_shared,shared_ptr和weak_ptr解决**  
例外:对于在同一个类中管理的成员，可使用new,delete,不扩散到其他地方即可  

- delete this  
在c++11之前，出现delete this情有可原。  
c++11后不应该再出现这种用法。  
**可用shared_ptr和weak_ptr解决**  

- 到处加锁  
在框架和应用层的很多地方调用加锁，这基本上可以肯定是一个不好的设计  
**建议:只应该在关键的几处加锁,最好是在框架内部处理，而应用层一般不需要自行加锁**  

- sleep  
**建议:sleep只应该出现在demo中，不应该出现在正式的框架和应用层代码中**  

- 滥用template  
 **仅在必须时使用template**  

- 滥用c++冷僻用法炫技  
 **建议:仅在适当时使用c++冷僻特性**  
 
 - 随意引入第三方开源库  
**建议:仅在认真评估开源库后才应用在产品中**   

- 随意使用全局变量  
**建议:如果可行，不要用全局变量,尽量减小变量作用域**    

- main函数中代码过多  
**建议:可以向MFC和IOS学习,采用精简的main函数**   
原因:  
main作为一个入口应该只做简单的事,应该尽快转到框架代码。  
另外main函数没法复用,你没法主动调用main  
如同OS在启动时从汇编转到C语言后，基本上很少调用直接用汇编写的代码了。  
在c++代码中也应该如此,应该从c接口main中马上转入c++ OOP风格框架。  


- C++有比java更好的GC  
C++11引入的smart pointer完全可实现GC的功能，并且在适用范围和可控性都比java GC要好。  
Java的GC貌似只能管理memory,不能管理其他资源。C++的RAII和析构函数可用来管理任何资源。  
java中的GC由vm接管，对coder来说不可见也不可控,无法预料。  
c++中shared_ptr和weak_ptr搭配使用，object的生命周期是完全由coder来控制的。  



 